{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/implementing-in-app-language-change","result":{"data":{"markdownRemark":{"html":"<p>Android resolves language- and culture-specific resources based on the system locale setting. This is a desired behavior that makes perfect sense. Despite it's officially not encouraged you may still need to write an app that allows the user to change its language without leaving it. In this article I will show you one of the possible ways to implement such feature.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/42412d8a57f51a62942c519394b85ffd/23942/communication.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.89189189189189%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwUA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAahJFKoYsX//xAAZEAEBAQEBAQAAAAAAAAAAAAABAgMAEiL/2gAIAQEAAQUC10ZSvSyQ7HaaMcfM/wD/xAAXEQADAQAAAAAAAAAAAAAAAAAAAREx/9oACAEDAQE/AcVKf//EABcRAQADAAAAAAAAAAAAAAAAAAABETH/2gAIAQIBAT8B2VP/xAAaEAACAwEBAAAAAAAAAAAAAAAAAQIRIRJh/9oACAEBAAY/AkkKPVlaxFQz0SP/xAAcEAADAAIDAQAAAAAAAAAAAAAAAREhUTFBYZH/2gAIAQEAAT8hV1hqt6JozPrwZ4yc2lrro9f2MjyNH//aAAwDAQACAAMAAAAQvM//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAEDAQE/EIhJ5p//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAECAQE/EA4SNv/EABwQAQEAAgIDAAAAAAAAAAAAAAERACExQWFxof/aAAgBAQABPxBhdQ+njHMc2eDtV5fWLNtN0fuGoAsRiYWVoDRhuh6xtvIVdqu1z//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Communication\"\n        title=\"Communication\"\n        src=\"/static/42412d8a57f51a62942c519394b85ffd/1c72d/communication.jpg\"\n        srcset=\"/static/42412d8a57f51a62942c519394b85ffd/a80bd/communication.jpg 148w,\n/static/42412d8a57f51a62942c519394b85ffd/1c91a/communication.jpg 295w,\n/static/42412d8a57f51a62942c519394b85ffd/1c72d/communication.jpg 590w,\n/static/42412d8a57f51a62942c519394b85ffd/a8a14/communication.jpg 885w,\n/static/42412d8a57f51a62942c519394b85ffd/fbd2c/communication.jpg 1180w,\n/static/42412d8a57f51a62942c519394b85ffd/23942/communication.jpg 4272w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<h1>The big picture</h1>\n<p>Before I start with the code, let me explain how this whole mechanism will work.</p>\n<p>I'm going to translate all the strings visible on the current application screen during the lifecycle callbacks (e.g. <code>Activity.onResume()</code> and <code>Fragment.onResume()</code>). This approach is easy to implement and understand and it currently covers all my needs. I won't try to force the app to translate itself magically. This means some overhead in the code for re-initializing all the texts and views which need to be translated.</p>\n<p>The following diagram illustrates the flow of getting a localized string by Activity:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/efb2fc3566ad475c660f5fe5216abcaf/01645/localization.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACRElEQVQoz02Sz0tiURTHv/ddfdM8yiHrqdOgQ87CIZ5oM/4LbgdazcLFm1WLFi3btIpWuhhfqyDnkVIQBEELFxaRP1BXmgtBX2YqJSL9XrVx4XAeBF0499wD53zP5xwuCoUCXl9f53u9nt7pdH5Xq1W8vLx8u7m5iV9dXWndbnfn+vpaHY/HeHh4+HV7e/vPMIy/w+FwezAYLD49Pf3p9/s77XY7/vz8rMHhcFgBTFEBmdvtngQw8RZ3Oh2cnZ2Bzvn5ObrdLgFgOBzi8fER9/f3GI1GZu7d3R3g9XpFEtR1XVleXv4K4IskSfPkNzc3PdFodEoQhE8AZEmS7JFIRNrY2CAAls1mGfnDw0O+vr5uobepHI1GYRjGgmEYM7FYzKTRdR35fP5nPB53UkNRFF0kqqqq4/j42NdsNlGpVMxczjkYY8wMMpkMI/xarbZQq9Xsg8EABwcHAiWXSqWApmkOAFabzUaTMEVRBFVVLeFwGGtra/D5fAgEAszv9wt+vx9Ip9Os3W6bghcXF/Z6vU5kQrlcRrFYDKyurroBzHHOSdhG4iTs8XhMoLddv5l5JZNJNBqN761WazqbzeLy8lI4OjpCLpcLrqysUCW3Wq20x88AXIwxWoOLc04NxKWlpdm9vT05lUoBiqJMABBOTk4WT09PiUJ0uVwz1Cifz//Y39+fJRKn02kB8BEAxVTDZVkmWuzu7s6Wy2UvTQVZlj8AsCSTybmtra1JEgoGg5wSE4nEtKZpIn2HUCiEd4e9D96P/B80eh2Kj/klKwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Getting a string\"\n        title=\"Getting a string\"\n        src=\"/static/efb2fc3566ad475c660f5fe5216abcaf/fcda8/localization.png\"\n        srcset=\"/static/efb2fc3566ad475c660f5fe5216abcaf/12f09/localization.png 148w,\n/static/efb2fc3566ad475c660f5fe5216abcaf/e4a3f/localization.png 295w,\n/static/efb2fc3566ad475c660f5fe5216abcaf/fcda8/localization.png 590w,\n/static/efb2fc3566ad475c660f5fe5216abcaf/efc66/localization.png 885w,\n/static/efb2fc3566ad475c660f5fe5216abcaf/01645/localization.png 1091w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<p>The flow involves <code>StringLocalization</code> object which has a map containing all the available <code>Resources</code> and that uses <code>AppSettings</code> to get current language that was set by the user.</p>\n<h1>Storing user preferences</h1>\n<p>To keep the chosen language between app restarts, we will store the preference in <code>SharedPreferences</code>. But first, let's declare an enum class to represent our languages and an object with locale codes to avoid hardcoding values in various places.</p>\n<pre><code class=\"language-kotlin\">object LocaleCodes {\n    const val ENGLISH = \"en\"\n    const val POLISH = \"pl\"\n    const val GERMAN = \"de\"\n}\n\nenum class Language(val locale: Locale) {\n    English(Locale(LocaleCodes.ENGLISH)),\n    German(Locale(LocaleCodes.GERMAN)),\n    Polish(Locale(LocaleCodes.POLISH));\n\n    companion object {\n        val DEFAULT = English\n\n        fun fromLocale(locale: Locale): Language =\n                values().firstOrNull { it.locale.language == locale.language } ?: DEFAULT\n    }\n}\n</code></pre>\n<p>Additionally, the enum class has a static <code>DEFAULT</code> value and <code>fromLocale</code> function which we will use later on.</p>\n<p>Now, let's implement a class for storing user preferences:</p>\n<pre><code class=\"language-kotlin\">interface AppSettings {\n    var currentLanguage: Language\n}\n\nclass SharedPrefAppSettings(\n    private val sharedPref: SharedPreferences,\n    private val androidConfiguration: Configuration\n) : AppSettings {\n\n    private var currentLanguageCache: Language? = null\n\n    override var currentLanguage: Language\n        get() {\n            val cachedValue = currentLanguageCache\n\n            return if (cachedValue == null) {\n                val storedValue = sharedPref.getString(APP_LANGUAGE_KEY, \"\")\n                val storedLanguage = try {\n                    Language.valueOf(storedValue)\n                } catch (ex: Exception) {\n                    null\n                }\n\n                val language = storedLanguage ?: getDefaultLanguage()\n\n                currentLanguage = language\n\n                language\n            } else cachedValue\n        }\n        set(value) {\n            currentLanguageCache = value\n            sharedPref.edit().putString(APP_LANGUAGE_KEY, value.toString()).apply()\n        }\n\n    private fun getDefaultLanguage(): Language {\n        val locale = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n            androidConfiguration.locales[0]\n        } else {\n            androidConfiguration.locale\n        }\n\n        return Language.fromLocale(locale)\n    }\n\n    companion object {\n        private const val APP_LANGUAGE_KEY = \"app_language\"\n    }\n}\n</code></pre>\n<p>I don't like to say the code is self-explanatory so let me tell you what's going on.\nStoring the chosen language is quite simple: we cache its value in <code>currentLanguageCache</code> and store it in <code>SharedPreferences</code> at <code>APP_LANGUAGE_KEY</code>.\nGetting the language is a bit more complicated, especially when the app is launched for the first time:</p>\n<ul>\n<li>we use the cached value if it's present</li>\n<li>if we don't have it yet, we read from <code>SharedPreferences</code></li>\n<li>then we try to get our enum from that value</li>\n<li>\n<p>if we can't get it properly (because there was no value in <code>SharedPrefereces</code> or we read something that can't be represented by our enum), we get a default language using <code>getDefaultLanguage()</code></p>\n<ul>\n<li>we read the <code>Locale</code> the app was started with from <code>Configuration</code> (it comes from <code>context.resources.configuration</code>)</li>\n<li>then we try to get our enum value from that <code>Locale</code></li>\n<li>in worst case scenario we end up with the <code>Language.DEFAULT</code> value</li>\n</ul>\n</li>\n<li>we cache the resulting language by calling the setter: <code>currentLanguage = language</code></li>\n</ul>\n<p>We will use Dagger to inject <code>SharedPrefAppSettings</code> implementation of the <code>AppSettings</code> interface thanks to this simple module:</p>\n<pre><code class=\"language-kotlin\">@Module\nclass AppSettingsModule {\n    @Provides\n    @Singleton\n    fun provideAppSettings(context: Context, configuration: Configuration): AppSettings =\n            SharedPrefAppSettings(PreferenceManager.getDefaultSharedPreferences(context), configuration)\n}\n</code></pre>\n<h1>Initializing locale-specific resources</h1>\n<p>In order to access resources defined for a specific locale, we need to do the following:</p>\n<ul>\n<li>make a new copy of your current resources <code>Configuration</code></li>\n<li>set the desired locale with <code>setLocale()</code></li>\n<li>create a configuration context with <code>context.createConfigurationContext()</code></li>\n<li>get resources from the new context</li>\n</ul>\n<p>so the code can look like this:</p>\n<pre><code class=\"language-kotlin\">val conf = Configuration(context.resources.configuration)\nconf.setLocale(Locale(LocaleCodes.ENGLISH))\nval localizedContext = context.createConfigurationContext(conf)\nval localizedResources = localizedContext.resources\n</code></pre>\n<p>Now we can generate a map of resources for each language. As usual, there are plenty of ways you can do it. In this example we use Dagger <a href=\"https://google.github.io/dagger/multibindings#map-multibindings\">map multibindings</a>.</p>\n<p>First, let's define a <code>LanguageKey</code> annotation so that we can have a map with <code>Language</code> enum keys:</p>\n<pre><code class=\"language-kotlin\">@MustBeDocumented\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\n@MapKey\nannotation class LanguageKey(val value: Language)\n</code></pre>\n<p>Next, we use it to generate multiple <code>Resources</code>:</p>\n<pre><code class=\"language-kotlin\">@Module\nclass LocalizationModule {\n\n    @Provides\n    @IntoMap\n    @LanguageKey(Language.English)\n    fun providesEnglishResources(context: Context): Resources =\n        getLocalizedResources(context, Language.English.locale)\n\n    @Provides\n    @IntoMap\n    @LanguageKey(Language.Polish)\n    fun providesPolishResources(context: Context): Resources =\n        getLocalizedResources(context, Language.Polish.locale)\n\n    @Provides\n    @IntoMap\n    @LanguageKey(Language.German)\n    fun providesGermanResources(context: Context): Resources =\n        getLocalizedResources(context, Language.German.locale)\n\n    private fun getLocalizedResources(context: Context, locale: Locale): Resources {\n        val conf = Configuration(context.resources.configuration)\n        conf.setLocale(locale)\n        val localizedContext = context.createConfigurationContext(conf)\n        return localizedContext.resources\n    }\n}\n</code></pre>\n<p>And voila, we can now inject <code>Map&#x3C;Language, Resources></code> with Dagger.</p>\n<h1>Providing string resources</h1>\n<p>Finally, it's time to add a helper class that will provide string resources from the generated map.</p>\n<pre><code class=\"language-kotlin\">@Singleton\nclass StringsLocalization @Inject constructor(\n        private val settings: AppSettings,\n        private val resMap: Map&#x3C;Language, @JvmSuppressWildcards Resources>\n) {\n\n    private val log = logger\n\n    fun getString(@StringRes stringId: Int): String = resMap\n            .getOrElse(settings.currentLanguage, this::getFallbackResources)\n            .getString(stringId)\n\n    private fun getFallbackResources(): Resources {\n        val defaultLanguage =\n                if (Language.DEFAULT in resMap) Language.DEFAULT\n                else resMap.keys.firstOrNull()\n\n        if (defaultLanguage != null) {\n            log.error(\"Current language resources not found. Fallback to: {}\", defaultLanguage)\n            settings.currentLanguage = defaultLanguage\n\n            return resMap[defaultLanguage]!!\n        } else {\n            throw ResourcesNotFoundException(\"String resources not found\")\n        }\n    }\n}\n\nclass ResourcesNotFoundException(message: String) : RuntimeException(message)\n</code></pre>\n<p>Both <code>AppSettings</code> (i.e. <code>SharedPrefAppSettings</code>) and the resources map will be injected by Dagger.\nYou can see the <code>getString()</code> method that takes string resource ID, just like the regular <code>Activity.getString()</code> method. It will get the language from <code>AppSettings</code> and use it to retrieve the proper <code>Resources</code> from the map. If the map doesn't contain anything at that language key for some reason, we will use <code>getFallbackResources()</code> method as a last resort before failing to provide a string.</p>\n<h1>Making it work</h1>\n<p>All we have to do now is to inject <code>StringsLocalization</code> object into the Activities and Fragments and use it to translate whatever we need.\nBut first, let's write a helper interface to make this task less boilerplate:</p>\n<pre><code class=\"language-kotlin\">interface HasStringsLocalization {\n    val stringsLocalization: StringsLocalization\n}\n\nfun HasStringsLocalization.getLocalizedString(@StringRes stringId: Int): String =\n        stringsLocalization.getString(stringId)\n</code></pre>\n<p>So now we can access strings with <code>getLocalizedString</code> easily like this:</p>\n<pre><code class=\"language-kotlin\">class WelcomeActivity : AppCompatActivity(), HasStringsLocalization {\n\n    @Inject\n    override lateinit var stringsLocalization: StringsLocalization\n\n    override fun onResume() {\n        super.onResume()\n        setTranslatedTexts()\n    }\n\n    private fun setTranslatedTexts() {\n        welcomeText.text = getLocalizedString(R.string.WELCOME)\n        // and more...\n    }\n}\n</code></pre>\n<p><em>Side note: I skipped some code here to make the example shorter and more readable. The full implementation could involve some kind of injection with Dagger, layout inflation, etc.</em></p>","excerpt":"Android resolves language- and culture-specific resources based on the system locale setting. This is a desired behavior that makes perfect…","frontmatter":{"slug":null,"title":"Implementing in-app language change","description":null,"author":"azabost","tags":["android","java","kotlin","language","dagger"],"date":"2018-02-14T23:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/42412d8a57f51a62942c519394b85ffd/dbc78/communication.jpg","srcSet":"/static/42412d8a57f51a62942c519394b85ffd/8b617/communication.jpg 1068w,\n/static/42412d8a57f51a62942c519394b85ffd/e0125/communication.jpg 2136w,\n/static/42412d8a57f51a62942c519394b85ffd/dbc78/communication.jpg 4272w","sizes":"(min-width: 4272px) 4272px, 100vw"},"sources":[{"srcSet":"/static/42412d8a57f51a62942c519394b85ffd/a71eb/communication.webp 1068w,\n/static/42412d8a57f51a62942c519394b85ffd/faeff/communication.webp 2136w,\n/static/42412d8a57f51a62942c519394b85ffd/8e1f3/communication.webp 4272w","type":"image/webp","sizes":"(min-width: 4272px) 4272px, 100vw"}]},"width":4272,"height":2848}}}},"timeToRead":6,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-15-implementing-in-app-language-change.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-15-implementing-in-app-language-change.md"}},"staticQueryHashes":["2189233960","3181594896"]}