{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/resigining-apk-manually","result":{"data":{"markdownRemark":{"html":"<p>Either you upload your app first time or update it, the application has to fulfill several requirements before it will be uploaded to the store (check <a href=\"https://support.google.com/googleplay/android-developer/answer/113469\">upload</a> and <a href=\"https://support.google.com/googleplay/android-developer/answer/113476\">update</a> requirements list). In this post let’s focus on signing an application.</p>\n<h2>About signing an application</h2>\n<blockquote>\n<p>“Android requires that all APKs be digitally signed with a certificate before they can be installed”</p>\n</blockquote>\n<p>What does it mean? Generally speaking, Android can identify an author of the application based on the certificate and recognize which application it can trust. It allows trusted application to be easily upgraded when an update is available in the store, allows applications with the same certificate share processes and, with using signature-based permissions checks, your applications can share code and data in a secure manner. Also mind that signing is required not only to be uploaded to the store but also to be even installed on Android OS. This means even your debug versions of application got their own certificates. Nevertheless, we don’t need to worry about that because compiler signs it with debug certificate every time we build the project so we could not worry about the process and just test functionality. Another thing is no certificate authority is needed and self-signed certificates might be used to sign your application. The certificate contains also the expiration date. It is checked at installation time, so when your certificate expires app will function normally, but could not be updated anymore.</p>\n<h2>Keystore</h2>\n<p>What is keystore?</p>\n<blockquote>\n<p>“This class represents a storage facility for cryptographic keys and certificates.”</p>\n</blockquote>\n<p>In practice keystore is a file that contains a block of encrypted data. It is defined with two aspects: keystore name and an alias. One file can store multiple aliases, so app certificate is described with keystore-alias key pair. Under alias keystore stores private key and other metadata identifying the owner of the key, such as Full Name, Organization, City, etc. Saving these data is not required.</p>\n<p>To generate a keystore you need keytool which is provided with Java JDK. This is standard command generating keystore:<br>\n<code>keytool -genkey -v -keystore mySecretKeystore.keystore -alias myAlias -keyalg RSA -keysize 2048 -validity 10000</code><br>\nwhere keystore name and alias name are up to you. Keyalg describes the algorithm used to generate keypair, you may choose different as you wish, same for keysize. Validity, specified in days, should be at least 25 years (Google Play requirements).</p>\n<h2>Signing</h2>\n<p>Signing an application might go 2 ways: sign with Gradle/ Android Studio or sign manually. Let's take a look at manually signing. For that, you'll need <code>apksigner</code> tool which is located in your Android SDK directory under <code>/build-tools/{VERSION}/</code> .</p>\n<p>For signing your app you need 2 files, <code>.apk</code> and <code>.keystore</code></p>\n<pre><code>myAwesomeApp.apk\nmySecretKeystore.keystore\n</code></pre>\n<p>If you have <code>.keystore</code> file you can list it's certificates with <code>keytool</code>:<br>\n<code>keytool -list -keystore ./mySecretKeystore.keystore -v -storepass mySecretPassword</code></p>\n<pre><code>Valid from: Sun Mar 18 23:40:12 CET 2012 until: Thu Mar 19 23:40:12 CET 2037\nCertificate fingerprints:\n     MD5:  59:**:**:**:**:**:**:**:**:**:**:**:**:**:**:EC\n     SHA1: E2:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:9B\n     SHA256: 07:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:**:6D\n     Signature algorithm name: SHA1withRSA\n     Version: 3\n</code></pre>\n<p>Result contains informations about fingerprints and validation dates.</p>\n<p>Now sign your <code>.apk</code> file with <code>apksigner</code> tool which comes with Android SDK tools:<br>\n<code>apksigner sign --ks ./mySecretKeystore.keystore --out ./myAwesomeApp-signed.apk ./myAwesomeApp.apk</code>   </p>\n<p>The last step is to zip align <code>.apk</code>. The alignment is an integer that defines the byte-alignment boundaries. This must always be 4, which provides 32-bit alignment.\n<code>zipalign 4 ./myAwesomeApp-signed.apk myAwesomeApp-aligned.apk</code></p>\n<p>And then check result with <code>apksigner verify</code>:<br>\n<code>apksigner verify -v --print-certs ./myAwesomeApp-signed.apk</code>  </p>\n<pre><code>Signer #1 certificate SHA-256 digest: 07************************************************************6d\nSigner #1 certificate SHA-1 digest: e2************************************9b\nSigner #1 certificate MD5 digest: 59****************************ec\nSigner #1 key algorithm: RSA\nSigner #1 key size (bits): 1024\nSigner #1 public key SHA-256 digest: 92************************************************************de\nSigner #1 public key SHA-1 digest: 67************************************fe\nSigner #1 public key MD5 digest: 92****************************2d\n</code></pre>\n<h2>Dealing with legacy apps - case study</h2>\n<p>Happened to me once I got to upload new application as an update of old version developed by some else. As was mentioned, when updating app the certificate should be the same, so I received keystore file in <code>.p12</code> extension, which represents <code>pkcs12</code> format, commonly used to store keys for iOS applications. Why was it needed in this case? It turned out the previous version of an app was developed with Adobe Flash Professional CC and key generated with Adobe Air Certificate Generator as a standard procedure few years ago. Why is it important? Well... <strong><em>Android applications signing process was changing over time</em></strong>, which means <strong><em>good luck with signing legacy apps</em></strong>.</p>\n<p><code>keytool</code> allows you to convert <code>.p12</code> to <code>JKS</code> (Java KeyStore) format with <code>importkeystore</code> option. Does it solve the problem? Unfortunately not. <code>apksigner</code> changes fingerprint in app while signing with imported keystore and Google Play will reject your app. Going through exactly the same workflow described above printing certificates shows two different ones.<br>\nkeystore: <code>SHA1: E2: ... :9B</code><br>\napk: <code>SHA1: 0B: ... :9A</code></p>\n<p>The answer is to use <code>jarsigner</code> tool.</p>\n<p>An APK file is an archive. Among others it has “META-INF” directory containing three files:</p>\n<ul>\n<li><code>MANIFEST.MF</code>: the Manifest file</li>\n<li><code>CERT.RSA</code>: The certificate of the application.</li>\n<li><code>CERT.SF</code>: The list of resources and SHA-1 digest of the corresponding lines in the MANIFEST.MF file</li>\n</ul>\n<p>For signing with <code>jarsigner</code> we have to:   </p>\n<ol>\n<li>edit <code>.apk</code> file and delete <code>META-INF</code> directory.<br>\n<code>zip -d myAwesomeApp.apk \"META-INF/*\"</code>   </li>\n<li>sign with <code>jarsigner</code><br>\n<code>jarsigner -keystore pkcs12Keystore.p12 -storepass mySecretPassword -storetype pkcs12 myAwesomeApp.apk myAlias</code></li>\n<li>zip align file<br>\n<code>zipalign 4 myAwesomeApp.apk myAwesomeApp-aligned.apk</code></li>\n</ol>\n<p>That is it. Now fingerprints matches<br>\nkeystore: <code>SHA1: E2: ... :9B</code><br>\napk: <code>SHA1: E2: ... :9B</code></p>","excerpt":"Either you upload your app first time or update it, the application has to fulfill several requirements before it will be uploaded to the…","frontmatter":{"slug":null,"title":"Signing APK file manually","description":null,"author":"radek","tags":["android","signing","apk","application publishing"],"date":"2017-10-29T23:00:00.000Z","image":null},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-10-30-resigining-apk-manually.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-10-30-resigining-apk-manually.md"}},"staticQueryHashes":["2189233960","3181594896"]}