{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/microbenchmarking-on-android","result":{"data":{"markdownRemark":{"html":"<p>Since Kotlin becomes more and more popular, especially amongst Android developers (and it's <a href=\"https://android-developers.googleblog.com/2017/05/android-announces-support-for-kotlin.html\">officially supported by Google</a>), some people decided to compare its runtime performance with Java. After reading a few articles I wanted to test it myself and now I'm ready to share some of my observations and experiences.</p>\n<h1>What is it about?</h1>\n<p>Microbenchmarking is just micro-scale benchmarking :-) It's about measuring the performance of something really \"small\" that may take just micro- or nanoseconds, like calling a function or iterating over a collection.</p>\n<p>I really recommend to read <a href=\"https://github.com/google/caliper/wiki/JavaMicrobenchmarks\">this wiki page on GitHub</a> as it summarizes a few very important aspects of microbenchmarking, including its fallibility and some possible reasons why you could ever consider doing it. It also explains why you should actually avoid writing microbenchmarks as there are only a few reasonable excuses for doing it (mostly when you develop a performance-critical library or framework).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/67fac731b26b0f175a8618e45ba60ed6/eea4a/hourglass-2910948_1280.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.89189189189189%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAGsxK1hoCIn/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAESEBH/2gAIAQEAAQUCfbymUUz/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPwGI/8QAFhEBAQEAAAAAAAAAAAAAAAAAABES/9oACAECAQE/AdK//8QAFxABAAMAAAAAAAAAAAAAAAAAEQEgMv/aAAgBAQAGPwLUjb//xAAbEAACAgMBAAAAAAAAAAAAAAAAEQEhEDFRYf/aAAgBAQABPyGS+IqWbN02Me0n/9oADAMBAAIAAwAAABBr/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/EA//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8Qhl//xAAcEAEBAAICAwAAAAAAAAAAAAABEQAhEEFRscH/2gAIAQEAAT8QowFqmiXxcpwRkPYN3ASnvCP2z//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Hourglass\"\n        title=\"Hourglass\"\n        src=\"/static/67fac731b26b0f175a8618e45ba60ed6/1c72d/hourglass-2910948_1280.jpg\"\n        srcset=\"/static/67fac731b26b0f175a8618e45ba60ed6/a80bd/hourglass-2910948_1280.jpg 148w,\n/static/67fac731b26b0f175a8618e45ba60ed6/1c91a/hourglass-2910948_1280.jpg 295w,\n/static/67fac731b26b0f175a8618e45ba60ed6/1c72d/hourglass-2910948_1280.jpg 590w,\n/static/67fac731b26b0f175a8618e45ba60ed6/a8a14/hourglass-2910948_1280.jpg 885w,\n/static/67fac731b26b0f175a8618e45ba60ed6/fbd2c/hourglass-2910948_1280.jpg 1180w,\n/static/67fac731b26b0f175a8618e45ba60ed6/eea4a/hourglass-2910948_1280.jpg 1280w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<h1>How do I start?</h1>\n<p>Writing a microbenchmark can be as simple as running some piece of code in a loop and measuring the time. You can also use one of the existing frameworks which have some useful features like the possibility to easily configure the way your benchmarks will be executed.</p>\n<p>Unfortunately, if you are willing to perform the tests on Android, you can't use probably the most advanced library, <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a>, as it uses some part of the Java API not available in Android API. This fact might discourage you from using Android platform for your benchmarks but you should bear in mind ART and Dalvik have significantly different characteristics from the JVM so optimizing code for JVM may be pessimizing it for Android (take a look at <a href=\"https://github.com/google/gson/commit/084047d80b582317f382536604373cafa14583a4\">this commit in Gson library</a>).</p>\n<h2>Manual measurements</h2>\n<p>The simplest way to measure the execution time of some code block is to call it large number of times in a loop like below:</p>\n<pre><code class=\"language-kotlin\">fun measure() {\n    val reps: Long = 1_000_000\n\n    var sum: Long = 0L\n\n    val callFuncBegin = System.nanoTime()\n\n    for (i in 0 until reps) {\n        sum += addConst(i)\n    }\n\n    val callFuncEnd = System.nanoTime()\n    val callFuncDiff = Math.abs(callFuncEnd - callFuncBegin)\n\n    println(sum)\n\n    val result = callFuncDiff / reps\n\n    println(result)\n}\n\nfun addConst(number: Long): Long {\n    return 5 + number\n}\n</code></pre>\n<p>In this example we benchmark the <code>addConst</code> function. If you are new to microbenchmarking, I bet you have a few questions.</p>\n<p>First of all, we need multiple <code>addConst</code> calls for a few reasons, for example because <code>System.nanoTime()</code> doesn't really need to be that accurate as you might think. The documentation says it clearly:</p>\n<blockquote>\n<p>This method provides nanosecond precision, but not necessarily nanosecond resolution (that is, how frequently the value changes) - no guarantees are made except that the resolution is at least as good as that of currentTimeMillis().</p>\n</blockquote>\n<p>Another reason is to get more confident results as the test environment (the smartphone) is very complex and it surely will take different amount of time for each execution.</p>\n<p>It is also important to keep in mind that <code>System.nanoTime()</code> might be relatively expensive in terms of execution time so we definitely should NOT put it inside the same loop as the measured function, unless all we want to measure is <code>System.nanoTime()</code> itself (been there, done that :-) ). So this is another reason why we need to call the desired function multiple times - to compensate <code>System.nanoTime()</code> overhead.</p>\n<p>Another aspect is that we need a function that has some observable effects, e.g. returning a result that is accumulated and then printed out. Otherwise, the compiler could cut out the code that was meant to be measured (see: <a href=\"https://github.com/google/caliper/wiki/JavaMicrobenchmarkReviewCriteria\">Could a compiler possibly optimize your benchmark away?</a>).</p>\n<h2>Spanner</h2>\n<p>Another way to benchmark the code is to use a dedicated framework like <a href=\"https://github.com/cmelchior/spanner\">Spanner</a>. It's an Android-oriented, <a href=\"https://github.com/google/caliper\">Caliper</a>-like library which can make this task easier. Despite its alpha-ish state, it's quite usable and worth trying out.</p>\n<p>Putting configuration matters aside, the benchmark function may look like this:</p>\n<pre><code class=\"language-kotlin\">@Benchmark\nfun addConstTest(reps: Long): Long {\n    var sum = 0L\n    for (i in 0 until reps) {\n        sum += addConst(i)\n    }\n    return sum\n}\n\nfun addConst(number: Long): Long {\n    return 5 + number\n}\n</code></pre>\n<p>As you can see, the framework gives us the required repetitions count as a parameter and it's our job to actually run the code in a loop.</p>\n<p><em>Side note: the current Spanner version (as of Feb 2, 2018) requires benchmark classes' and methods' modifiers to be exacly <code>java.lang.reflect.Modifier.PUBLIC</code> so you can't run final-by-default Kotlin code without additional <code>open</code> modifier. That's why I use my <a href=\"https://github.com/azabost/spanner\">forked version</a> with this behavior changed accordingly.</em></p>\n<p>Spanner can also upload your benchmark results to <a href=\"https://microbenchmarks.appspot.com\">https://microbenchmarks.appspot.com</a> either anonymously or with a given API key.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9f15ed18e351a656418ac58c622e7e74/e4900/spanner-result.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.35135135135135%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB4klEQVQoz3WR6W7aUBBG/f7v0zZdktAkgrCF2E4qMMGA19gYr4B3TuWrpBI/eqWjkebTfHcWybVv0Fdfsa1fGNvvrPUrTOMHrtPlvwkt3M8wzQWLhYau68iyTK/XYzgcMh5PWC6XaJomkOpqQV3NaZsFUTjFdQaE+wn7YEJZ/KGp51TlnNPJJ45THMfB932iKCJNU8HhcPiH1NRrwABMHGuEZQ5x7DGuMyHPNcDi3Opwzqjrlt1ux/F45H9PamqdNHkh2M1Yar8F69UD200f33siChWKfEHbpoRhjG1bhGFIlmXC+Hw+XyCVxRuOPcLYDnCdMaYxEEbe+5R3Zyzyh+yVtknwvJ0Ytxtzv98TBAF5ngs6czFyftLwvakwcO0RtjVk5z+Jjru8789IE1UYBkEoTLriOI6J44QkScQHURSLKLVNt59uj1uiUMbY9lnrD6LTRmgbzu2Kpo7x/QDLMomiUBh2h2nb9nKHVbmmqTdUpY5rT9msH1m99TGNEceDJrS6WlEWEb4f4nndhT+7DamqRhzrE0lWTshKIVDUEkUtkNUC9aXk/sHi5lbn7t7k5/Ubd/cu42nGs1KjqA1yh1JfIGUjlePohaOIl6SPz6yuesy/XIvo3PZJBrMPXfngsuYvqZXi8PE87E8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Spanner results\"\n        title=\"Spanner results\"\n        src=\"/static/9f15ed18e351a656418ac58c622e7e74/fcda8/spanner-result.png\"\n        srcset=\"/static/9f15ed18e351a656418ac58c622e7e74/12f09/spanner-result.png 148w,\n/static/9f15ed18e351a656418ac58c622e7e74/e4a3f/spanner-result.png 295w,\n/static/9f15ed18e351a656418ac58c622e7e74/fcda8/spanner-result.png 590w,\n/static/9f15ed18e351a656418ac58c622e7e74/efc66/spanner-result.png 885w,\n/static/9f15ed18e351a656418ac58c622e7e74/e4900/spanner-result.png 988w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<h1>What could possibly go wrong?</h1>\n<p>It's very easy to get horribly misleading results, especially if you don't follow some rules when writing microbenchmarks. For example, <a href=\"http://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html\">this article</a> by Julien Page shows how benchmarks may be optimized by the JVM so that the results become meaningless. A few criteria of a good benchmark have also been defined on <a href=\"https://github.com/google/caliper/wiki/JavaMicrobenchmarkReviewCriteria\">this Caliper wiki page</a>. And in <a href=\"https://github.com/melix/jmh-gradle-example/blob/master/src/jmh/java/org/openjdk/jmh/samples/JMHSample_11_Loops.java\">this example</a> Cédric Champeau proves why it's so important to use the right tool for measurements (like JMH).</p>\n<p>Of course there are more issues that may happen, e.g.:</p>\n<ul>\n<li>garbage collection occurring during the measurements,</li>\n<li>temporarily increased CPU usage by other apps,</li>\n<li>JIT compiler making your code run faster each time,</li>\n<li>unavoidable CPU throttling.</li>\n</ul>\n<h1>Conclusion</h1>\n<p>Microbenchmarking is an interesting topic and I'm glad I could practice it myself and learn about it. As I've already mentioned, it's not something you should do on your daily basis, but still, I think it's worth reading about it and trying it out just to expand your horizons.</p>","excerpt":"Since Kotlin becomes more and more popular, especially amongst Android developers (and it's officially supported by Google), some people…","frontmatter":{"slug":null,"title":"Microbenchmarking on Android","description":null,"author":"azabost","tags":["android","java","kotlin","benchmark"],"date":"2018-02-07T23:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/67fac731b26b0f175a8618e45ba60ed6/f3dc5/hourglass-2910948_1280.jpg","srcSet":"/static/67fac731b26b0f175a8618e45ba60ed6/f6fcd/hourglass-2910948_1280.jpg 320w,\n/static/67fac731b26b0f175a8618e45ba60ed6/e70fc/hourglass-2910948_1280.jpg 640w,\n/static/67fac731b26b0f175a8618e45ba60ed6/f3dc5/hourglass-2910948_1280.jpg 1280w","sizes":"(min-width: 1280px) 1280px, 100vw"},"sources":[{"srcSet":"/static/67fac731b26b0f175a8618e45ba60ed6/dde70/hourglass-2910948_1280.webp 320w,\n/static/67fac731b26b0f175a8618e45ba60ed6/62859/hourglass-2910948_1280.webp 640w,\n/static/67fac731b26b0f175a8618e45ba60ed6/f121e/hourglass-2910948_1280.webp 1280w","type":"image/webp","sizes":"(min-width: 1280px) 1280px, 100vw"}]},"width":1280,"height":853}}}},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-08-microbenchmarking-on-android.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-08-microbenchmarking-on-android.md"}},"staticQueryHashes":["2189233960","3181594896"]}