{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/using-typescript-with-redux","result":{"data":{"markdownRemark":{"html":"<p>Recently we've checked <a href=\"https://brightinventions.pl/blog/5-ways-to-benefit-from-typescript-in-react/\">what benefits TypeScript adds in our React project</a>. Let's now follow the typical path the front-end project takes nowadays and add <a href=\"https://brightinventions.pl/blog/from-react-to-react-redux-in-a-few-steps/\">Redux</a> into the mix. Unfortunately, by default Redux is not really type safe as it is in most cases presented as <a href=\"https://redux.js.org/introduction/core-concepts\">switches over actions with arbitrary payloads</a>. But TypeScript is a powerful beast and with a bit of care we can make our Redux code not only type safe, but also much cleaner and more readable.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 556px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a46974cba93685af148784efe54781d2/96638/redux-ts.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.05405405405405%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACiUlEQVQoz5WTTUhUURTHz4xDJdiXiYkgQosW1SKSNi2CSOydMYs+KAIzCiqmLMVm7pv3ZvxoHC2lFpJCuwpctmuR6L0jKInNe+OMBpOEUWQZBi0qzRhe78R985Jq1+LPuZvzu/9z/veCigKkWo+OA0PunGVV6se8RcEkgGb4QDMyoJsEumm59R8ZtlM1Iwcqcgj7BdyoGZKg0wx5O0N+IFY9DAS3AHTTB7r5P0DhdV0FGPKLKopihjwWQq401gnYHphY6wA1wwF6XIjnD6BHN/8CSpUx5B1h/3B+ZGVkPUMRCBwRsOuyA0y7DRaEDVqVZuTBqutQN3POvhiKnQx5A0MeZ8iHGIpmhuJq/OBIIcED8GjGjGxe05qyNsbSVNg+RZtiafJFUwQsSSXxjO1e4ABLVBSNDPmVMCY2MIVXqpgoDyE/pyq8t+HEaClEU0kIPqfjg3PW1IdlkkovLNOxwTliT+dp9tOK3fdsUcIdIGPIqxjyVoa8Ju+YN4WQ39UP8R0ttaIdouaEdFjYlrL23X9JH7/maO9Alkq7MvRlxaLrT97Zlb0zvx2KjjxkRI48EFSctPuCfr67uVZAi1/0+MLGLERMglDS2tyZlo6ouDNN0DRJ5x+/kRfYXaML5I3kdxhkyE+qmChmKPYz5PdUFBfOnBovCCv8cEut0CBiTrrLt8pvT9Przz9oa3eG1rWlaE9/lrbdeWEv536S/+ErB1jIkF9iyKPy6agoKlQU1SHknWGFn1Xqx4pAN1N5YNIq685QdvE7bYmnSQaUnF8i8/2SPf72G1X0TOeAKdz9IQk38fz5Zg2Ha3UJgEez3tWfohmWN2JSWfc0FcgVsKRMnqr6s3ZRx5QTyi9B6NOrlqfkRAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Redux + TypeScript\"\n        title=\"Redux + TypeScript\"\n        src=\"/static/a46974cba93685af148784efe54781d2/96638/redux-ts.png\"\n        srcset=\"/static/a46974cba93685af148784efe54781d2/12f09/redux-ts.png 148w,\n/static/a46974cba93685af148784efe54781d2/e4a3f/redux-ts.png 295w,\n/static/a46974cba93685af148784efe54781d2/96638/redux-ts.png 556w\"\n        sizes=\"(max-width: 556px) 100vw, 556px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<h2>Basic typing</h2>\n<p>Let's dissect the classical To Do list example from the \"<a href=\"https://redux.js.org/introduction/core-concepts\">Core Concepts</a>\" introductory Redux guide's page step-by-step. The global app's state originally looks as follows:</p>\n<pre><code class=\"language-javascript\">{\n  todos: [{\n    text: 'Eat food',\n    completed: true\n  }, {\n    text: 'Exercise',\n    completed: false\n  }],\n  visibilityFilter: 'SHOW_COMPLETED'\n}\n</code></pre>\n<p>It is pretty straightforward to create a type definition for this state:</p>\n<pre><code class=\"language-typescript\">interface Todo {\n    text: string\n    completed: boolean\n}\n\ntype VisibilityFilter = 'SHOW_COMPLETED' | 'SHOW_ALL'\n\ninterface AppState {\n    todos?: Todo[]\n    visibilityFilter?: VisibilityFilter\n}\n</code></pre>\n<p>Note that <code>AppState</code>'s properties are optional as the state might initially be empty and we need to handle it in our code and thus reflect it in our type definition.</p>\n<p>So far so good. Now Actions – they initially look like this:</p>\n<pre><code class=\"language-javascript\">{ type: 'ADD_TODO', text: 'Go to swimming pool' }\n{ type: 'TOGGLE_TODO', index: 1 }\n{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }\n</code></pre>\n<p>Let's for now use the typing provided by <a href=\"https://github.com/reactjs/redux/blob/master/.d.ts\"><code>redux</code> library itself</a>, specifically <code>AnyAction</code> that only enforces the <code>type</code> property to be set:</p>\n<pre><code class=\"language-typescript\">const actions: AnyAction[] = [\n    { type: 'ADD_TODO', text: 'Go to swimming pool' },\n    { type: 'TOGGLE_TODO', index: 1 },\n    { type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }\n]\n</code></pre>\n<p>Better than nothing, we can't have an Action without a type at least and we can put arbitrary data into it.</p>\n<p>Now let me jump to Reducers. Reducers in the original example are implemented this way:</p>\n<pre><code class=\"language-javascript\">function visibilityFilter(state = 'SHOW_ALL', action) {\n  if (action.type === 'SET_VISIBILITY_FILTER') {\n    return action.filter\n  } else {\n    return state\n  }\n}\n​\nfunction todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([{ text: action.text, completed: false }])\n    case 'TOGGLE_TODO':\n      return state.map(\n        (todo, index) =>\n          action.index === index\n            ? { text: todo.text, completed: !todo.completed }\n            : todo\n      )\n    default:\n      return state\n  }\n}\n\n// top-level reducer\nfunction todoApp(state = {}, action) {\n  return {\n    todos: todos(state.todos, action),\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action)\n  }\n}\n</code></pre>\n<p>Let's use our State and Action type definitions as a first step:</p>\n<pre><code class=\"language-typescript\">function visibilityFilter(state: VisibilityFilter = 'SHOW_ALL', action: AnyAction): VisibilityFilter {\n  if (action.type === 'SET_VISIBILITY_FILTER') {\n    return action.filter\n  } else {\n    return state\n  }\n}\n​\nfunction todos(state: Todo[] = [], action: AnyAction): Todo[] {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([{ text: action.text, completed: false }])\n    case 'TOGGLE_TODO':\n      return state.map(\n        (todo, index) =>\n          action.index === index\n            ? { text: todo.text, completed: !todo.completed }\n            : todo\n      )\n    default:\n      return state\n  }\n}\n\n// top-level reducer\nfunction todoApp(state: AppState = {}, action: AnyAction): AppState {\n  return {\n    todos: todos(state.todos, action),\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action)\n  }\n}\n</code></pre>\n<p>Note that all reducers, regardless of on which level they exist, share the same generic signature:</p>\n<pre><code class=\"language-typescript\">type Reducer&#x3C;S> = (state: S, action: AnyAction) => S;\n</code></pre>\n<p>This is exactly the type that the built-in Redux typings provide, so we can use it in our code directly if we have an urge to generalize it more for some reason.</p>\n<h2>Can we do more?</h2>\n<p>All we have done so far was to add the basic type definitions that could prevent us from a set of typos. But looking at the reducers, we're far from an actual type safety as <code>AnyAction</code>-typed actions – as this <code>any</code> in the name suggests – does not give the TypeScript compiler any clue what payload the particular action type actually carries. We might still make a typo while accessing action's payload properties, assume its wrong type or use the properties of action of another type by mistake and TypeScript has no tool to warn us in this case:</p>\n<pre><code class=\"language-typescript\">function visibilityFilter(state: VisibilityFilter = 'SHOW_ALL', action: AnyAction): VisibilityFilter {\n    if (action.type === 'SET_VISIBILITY_FILTER') {\n        return action.fliter // note the typo here. TypeScript is unable to detect the problem here\n    } else {\n        return state\n    }\n}\n</code></pre>\n<p>But all hope is not lost yet. TypeScript has a powerful feature of <a href=\"https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html\">Discriminated Unions</a> and even though this name sounds like some kind of organization of a social minority, it might help us a lot here.</p>\n<p>Let's create detailed type definitions for each kind of action we support:</p>\n<pre><code class=\"language-typescript\">interface AddTodoAction extends Action {\n    type: 'ADD_TODO'\n    text: string\n}\n\ninterface ToggleTodoAction extends Action {\n    type: 'TOGGLE_TODO'\n    index: number\n}\n\ninterface SetVisibilityFilterAction extends Action {\n    type: 'SET_VISIBILITY_FILTER'\n    filter: VisibilityFilter\n}\n</code></pre>\n<p>Note that we extend Redux-provided <code>Action</code> now which only specifies a <code>type</code> property. <code>AnyAction</code> type we used before permits any property to exist in its implementations, so it defeats our desired type safety. Another interesting bit here is that we specify the <code>type</code> property with a literal, making it a good candidate for the discriminator of our discriminated union. Here is the union itself:</p>\n<pre><code class=\"language-typescript\">type TodoAppAction = AddTodoAction | ToggleTodoAction | SetVisibilityFilterAction\n</code></pre>\n<p>Now let's replace <code>AnyAction</code> in our reducers with <code>TodoAppAction</code> and let's see what happens now:</p>\n<pre><code class=\"language-typescript\">function visibilityFilter(state: VisibilityFilter = 'SHOW_ALL', action: TodoAppAction): VisibilityFilter {\n    if (action.type === 'SET_VISIBILITY_FILTER') {\n        return action.filter\n    } else {\n        return state\n    }\n}\n​\nfunction todos(state: Todo[] = [], action: TodoAppAction): Todo[] {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return state.concat([{text: action.text, completed: false}])\n        case 'TOGGLE_TODO':\n            return state.map(\n                (todo, index) =>\n                    action.index === index\n                        ? {text: todo.text, completed: !todo.completed}\n                        : todo\n            )\n        default:\n            return state\n    }\n}\n\nfunction todoApp(state: AppState = {}, action: TodoAppAction): AppState {\n    return {\n        todos: todos(state.todos, action),\n        visibilityFilter: visibilityFilter(state.visibilityFilter, action)\n    }\n}\n</code></pre>\n<p>If you use a TypeScript-aware IDE (like <a href=\"https://www.jetbrains.com/webstorm/\">WebStorm</a>, for example), you might notice that the action properties are now properly colored and the code completion works exactly as we might have dreamt. Let's now try our typo example again:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d971b9a7dbc825464a6cf68b045043c1/5b4a1/reducer-typo.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 14.864864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoUlEQVQI1y3KS3KEIBgAYY8ExSMI/ChoYiJxxqqscv+DdCqOi6+qFz3I3AjeUoNinSNbFZaaSZLJJSNTIYlgnMFYhXMO/xZIuRBjJoSRMWZiyhhjGba905aV42vl96fzfJyc58n+3S/9cdCPg9oWplqZW7v+MUac9zjn8f7FWsvw8bmzvm/UpZKkkLJcshSk/Jtud0+vNsaglEJrjdbqpvkD6Ehm9MVwtO8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TypeScript properly checks Action payload types\"\n        title=\"TypeScript properly checks Action payload types\"\n        src=\"/static/d971b9a7dbc825464a6cf68b045043c1/fcda8/reducer-typo.png\"\n        srcset=\"/static/d971b9a7dbc825464a6cf68b045043c1/12f09/reducer-typo.png 148w,\n/static/d971b9a7dbc825464a6cf68b045043c1/e4a3f/reducer-typo.png 295w,\n/static/d971b9a7dbc825464a6cf68b045043c1/fcda8/reducer-typo.png 590w,\n/static/d971b9a7dbc825464a6cf68b045043c1/5b4a1/reducer-typo.png 831w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<p>A victory for humanity, isn't it?</p>\n<h2>Connected Components</h2>\n<p>One more place we might feel betrayed by Redux is where it actually <a href=\"https://redux.js.org/basics/usage-with-react\">binds into React components</a>. Let's use a bit simplified example from the Redux guide again:</p>\n<pre><code class=\"language-jsx\">import { connect } from 'react-redux'\nimport { setVisibilityFilter } from '../actions'\n\n// the component itself\n\nconst Link = ({active, children, onClick}) => {\n  if (active) {\n    return &#x3C;span>{children}&#x3C;/span>\n  }\n​\n  return &#x3C;a href=\"\" onClick={onClick}>\n    {children}\n  &#x3C;/a>\n}\n​\n// redux binding\n\nconst mapStateToProps = (state, ownProps) => {\n  return {\n    active: ownProps.filter === state.visibilityFilter\n  }\n}\n​\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    onClick: () => {\n      dispatch(setVisibilityFilter(ownProps.filter))\n    }\n  }\n}\n​\nconst FilterLink = connect(mapStateToProps, mapDispatchToProps)(Link)\n</code></pre>\n<p>Let's define the types for the <code>Link</code> component's props in the straightforward way:</p>\n<pre><code class=\"language-typescript\">interface LinkProps {\n    active: boolean\n    onClick: () => void\n}\n\nconst Link: React.StatelessComponent&#x3C;LinkProps> = props => {\n  if (props.active) {\n    return &#x3C;span>{props.children}&#x3C;/span>\n  }\n​\n  return &#x3C;a href=\"\" onClick={props.onClick}>\n      {props.children}\n  &#x3C;/a>\n}\n</code></pre>\n<p>This works fine, but this way we can't go further into <code>mapStateToProps</code> or <code>mapDispatchToProps</code> as these methods compose our final props object from independent parts and we either leave it untyped or describe it with some kind of workarounds like <code>Partial&#x3C;LinkProps></code> to at least give us the basic checks:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7319a38d5a6371672095b1c9a68ac506/4ef49/mapprops-partial-typo.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 12.837837837837837%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnUlEQVQI11XJQY6CQBBAUU4EmwGlaUAdY5Du6qoC73+Vb4Y4Cxcvf/GrsWuw35bleuY2doS+J4RIjBMhBIY4E08tw6nj3A/H60Pkp21pmoa6rr9U98cDSRkTR9XR4pSkFFFUDct/NjQbl+uNOE7Eaf7033x0nC9Uuu1kc4pvFHNWKdj+QswRNcSdrHb8VJRnFp65HJY1s6SPNbGK8gZuaGuFZF8t3AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Workaround on mapStateToProps might help a bit\"\n        title=\"Workaround on mapStateToProps might help a bit\"\n        src=\"/static/7319a38d5a6371672095b1c9a68ac506/fcda8/mapprops-partial-typo.png\"\n        srcset=\"/static/7319a38d5a6371672095b1c9a68ac506/12f09/mapprops-partial-typo.png 148w,\n/static/7319a38d5a6371672095b1c9a68ac506/e4a3f/mapprops-partial-typo.png 295w,\n/static/7319a38d5a6371672095b1c9a68ac506/fcda8/mapprops-partial-typo.png 590w,\n/static/7319a38d5a6371672095b1c9a68ac506/efc66/mapprops-partial-typo.png 885w,\n/static/7319a38d5a6371672095b1c9a68ac506/4ef49/mapprops-partial-typo.png 890w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<p>Note we don't have a proper type for <code>ownProps</code> here, too, and \"for convenience\" we used <code>any</code>. Also, this approach let us return <code>onClick</code> property here which we clearly expect to be returned only from <code>mapDispatchToProps</code> in this case. Let's be explicit about it and split our props into three separate types: one for own props (passed from the parent component), one for state-based props and one for dispatch-based props:</p>\n<pre><code class=\"language-typescript\">interface LinkOwnProps {\n    filter: VisibilityFilter\n}\n\ninterface LinkStateProps {\n    active: boolean\n}\n\ninterface LinkDispatchProps {\n    onClick: () => void\n}\n\ntype LinkProps = LinkOwnProps &#x26; LinkStateProps &#x26; LinkDispatchProps\n</code></pre>\n<p>And now our Redux bindings are fully type safe:</p>\n<pre><code class=\"language-typescript\">const mapStateToProps = (state: AppState, ownProps: LinkOwnProps): LinkStateProps => {\n    return {\n        active: ownProps.filter === state.visibilityFilter\n    }\n}\n\nconst mapDispatchToProps = (dispatch: Dispatch&#x3C;AppState>, ownProps: LinkOwnProps): LinkDispatchProps => {\n    return {\n        onClick: () => {\n            dispatch(setVisibilityFilter(ownProps.filter))\n        }\n    }\n}\n</code></pre>\n<p>For me the type safety given by proper TypeScript definitions made Redux great again. How about you?</p>","excerpt":"Recently we've checked what benefits TypeScript adds in our React project. Let's now follow the typical path the front-end project takes…","frontmatter":{"slug":null,"title":"Using TypeScript with Redux","description":null,"author":"adam","tags":["React","TypeScript","web"],"date":"2018-04-19T22:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#0878c8","images":{"fallback":{"src":"/static/a46974cba93685af148784efe54781d2/d8c4a/redux-ts.png","srcSet":"/static/a46974cba93685af148784efe54781d2/c0c81/redux-ts.png 139w,\n/static/a46974cba93685af148784efe54781d2/0c024/redux-ts.png 278w,\n/static/a46974cba93685af148784efe54781d2/d8c4a/redux-ts.png 556w","sizes":"(min-width: 556px) 556px, 100vw"},"sources":[{"srcSet":"/static/a46974cba93685af148784efe54781d2/6e3ed/redux-ts.webp 139w,\n/static/a46974cba93685af148784efe54781d2/73f03/redux-ts.webp 278w,\n/static/a46974cba93685af148784efe54781d2/ffc44/redux-ts.webp 556w","type":"image/webp","sizes":"(min-width: 556px) 556px, 100vw"}]},"width":556,"height":300}}}},"timeToRead":7,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-04-20-using-typescript-with-redux.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-04-20-using-typescript-with-redux.md"}},"staticQueryHashes":["2189233960","3181594896"]}