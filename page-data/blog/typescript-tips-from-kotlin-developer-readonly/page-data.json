{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/typescript-tips-from-kotlin-developer-readonly","result":{"data":{"markdownRemark":{"html":"<p>Last time I wrote about using <a href=\"%7B%25%20post_url%202018-04-11-typescript-tips-from-kotlin-developer-const%20%25%7D\"><code>const</code> in TypeScript</a>. This time I will focus on another TypeScript keyword that aids immutability: <code>readonly</code>.</p>\n<h2><code>readonly</code> properties</h2>\n<p>In Kotlin a <code>val</code> keyword can be used to declare a read only property:</p>\n<pre><code class=\"language-kotlin\">class Timer(val start: DateTime){\n    val elapsed: Duration get() = DateTime.now() - start\n}\n\nval now = Timer(DateTime.now())\nprintln(\"Elapsed: ${now.elapsed}\") \nnow.start = DateTime.now() // Error: Val cannot be reassigned\nnow.elapsed = DateTime.now() // Error: Val cannot be reassigned\n</code></pre>\n<p>In the above example we have 2 properties:</p>\n<ul>\n<li><code>start</code> is a read only property which value does not change</li>\n<li><code>elapsed</code> is a read only property that returns different values</li>\n</ul>\n<p>In <a href=\"https://www.typescriptlang.org/\">TypeScript</a> the equivalent behavior is achieved with a help of the <a href=\"https://www.typescriptlang.org/docs/handbook/interfaces.html#readonly-properties\"><code>readonly</code> keyword and getter only properties</a>:</p>\n<pre><code class=\"language-typescript\">class Timer {\n    constructor(readonly start: Date) { }\n\n    get elapsed(): number {\n        return new Date().getTime() - this.start.getTime();\n    } \n}\n\nconst now = new Timer(new Date())\nconsole.log(`elapsed: ${now.elapsed}`)\nnow.start = new Date() // Error: Cannot assign 'start' because it is a constant or a read-only \nnow.elapsed = new Date() // Error: Cannot assign 'elapsed' because it is a constant or a read-only \n</code></pre>\n<p>The above examples highlights an important difference between <code>const</code> and <code>readonly</code>: a <code>readonly</code> property value can change.</p>\n<p>Note that the error message we get when trying to assign <code>start</code> and <code>elapsed</code> is the same even though the properties are declared using different language constructs. This makes sense though. From the caller perspective both properties are read only.</p>\n<h2>Treat mutable as immutable with <code>Readonly&#x3C;T></code></h2>\n<p>One advantage TypeScript has over Kotlin is the ability to easily declare an immutable version of an interface.\nLet us assume that we have an existing interface that is naturally mutable e.g. any regular JavaScript object. </p>\n<pre><code class=\"language-typescript\">const ala = { firstName: \"Ala\", lastName: \"MaKota\", points: 0 }\n// let's use ala as a template and grab its type\ntype Person = typeof ala\n\nfunction newPersonWithBonusPoints(person: Person, amount: number): Person {\n    person.points = person.points + amount;\n    return person;\n}\n\nconst newAla = addPoints(ala, 3)\n</code></pre>\n<p>The function <code>newPersonWithBonusPoints</code> as the name suggests should return a new person with new <code>points</code> value. However, there it is still possible for us to make a mistake when implementing <code>newPersonWithBonusPoints</code> and mutate the supplied instance instead of creating a new one. How can we ensure <code>newPersonWithBonusPoints</code> function does not mutate the argument? With the help of <code>Readonly&#x3C;T></code> this is easy:</p>\n<pre><code class=\"language-typescript\">const ala = { firstName: \"Ala\", lastName: \"MaKota\", points: 0 }\n// let's use ala as a template and grab its type but make it read only\ntype Person = Readonly&#x3C;typeof ala>\n\nfunction newPersonWithBonusPoints(person: Person, amount: number): Person {\n    person.points = person.points + amount; //Error: Cannot assign to 'points' because it is a constant or a read-only property\n    return person;\n}\n</code></pre>\n<p>Notice how with a single <code>Readonly&#x3C;T></code> we can turn any type into its read only equivalent. It is worth mentioning that the <code>Readonly&#x3C;T></code> is shallow i.e. nested objects are still mutable unless explicitly stated otherwise. Thankfully version [TypeScript 2.8]\n(<a href=\"https://github.com/Microsoft/TypeScript/pull/21316\">https://github.com/Microsoft/TypeScript/pull/21316</a>) introduced an ability to define a <code>DeepReadonly&#x3C;T></code> that makes it possible to mark a type as immutable e.g.:</p>\n<pre><code class=\"language-typescript\">interface Address {\n    city: string\n    street: string\n}\n\ninterface Person {\n    address: Address | null\n    firstName: string\n    nickNames: string[]\n}\n\nconst ala: DeepReadonly&#x3C;Person> = {\n    address: { city: \"Gdańsk\", street: \"Słonimskiego\" },\n    firstName: \"Ala\",\n    nickNames: [\"lol\"]\n} as Person\n\n\nala.address.city = 'Name' // Error: cannot assign city because it is constant or readonly\nala.nickNames.push('Kot') // Error: property push does not exist on type DeepReadonlyArray&#x3C;string>\n</code></pre>\n<p>In the example above the compiler does not allow modifying nested <code>address</code> object. Interestingly it also forbids mutating the <code>nickNames</code> array.</p>\n<h3>Runtime safety with <code>Object.freeze</code></h3>\n<p>The <code>Readonly</code> and <code>DeepReadonly</code> will make it impossible to mutate an object in sane fashion in TypeScript code. However, at runtime it is still possible to inadvertently mutate an object where not desired or use a library that mutates a passed in parameter:</p>\n<pre><code class=\"language-typescript\">interface Config {\n    readonly port: string\n}\n// a problematic function that mutates an argument\nfunction start(config) { \n    const c = Object.assign(config, {\n        port: config.port ? parseInt(config.port) : 80\n    })\n}\n\nconst config: Config = {\n    port: '80'\n}\n\nstart(config)\n\nif (config.port === '80') { \n    console.log('Handle default http port'); // This will not be printed!\n}\n</code></pre>\n<p>To avoid such issues I often use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\"><code>Object.freeze</code></a> which will make the above example throw an error on the line with <code>Object.assign</code>: <code>TypeError: Cannot assign to read only property 'port' of object '#&#x3C;Object>'</code>. As you can see, the error is now reported right where the problem is introduced.</p>","excerpt":"Last time I wrote about using const in TypeScript. This time I will focus on another TypeScript keyword that aids immutability: readonly…","frontmatter":{"slug":null,"title":"TypeScript tips from Kotlin developer - readonly","description":null,"author":"piotr","tags":["TypeScript","Kotlin","readonly","immutability"],"date":"2018-05-01T22:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/100c0a289713fc0b1b8b98cabe2f94be/8a0e5/kotlin-logo.png","srcSet":"/static/100c0a289713fc0b1b8b98cabe2f94be/f2a56/kotlin-logo.png 38w,\n/static/100c0a289713fc0b1b8b98cabe2f94be/67bac/kotlin-logo.png 76w,\n/static/100c0a289713fc0b1b8b98cabe2f94be/8a0e5/kotlin-logo.png 152w","sizes":"(min-width: 152px) 152px, 100vw"},"sources":[{"srcSet":"/static/100c0a289713fc0b1b8b98cabe2f94be/0852d/kotlin-logo.webp 38w,\n/static/100c0a289713fc0b1b8b98cabe2f94be/984aa/kotlin-logo.webp 76w,\n/static/100c0a289713fc0b1b8b98cabe2f94be/da3f1/kotlin-logo.webp 152w","type":"image/webp","sizes":"(min-width: 152px) 152px, 100vw"}]},"width":152,"height":151}}}},"timeToRead":4,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-05-02-typescript-tips-from-kotlin-developer-readonly.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-05-02-typescript-tips-from-kotlin-developer-readonly.md"}},"staticQueryHashes":["2189233960","3181594896"]}