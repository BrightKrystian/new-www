{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/spring-mvc-request-timeout","result":{"data":{"markdownRemark":{"html":"<p><a href=\"%7B%25%20post_url%202017-11-21-spring-mvc-thread-pool-timeouts%20%25%7D\">As we saw previously</a>, we only have limited options to configure maximum time a request processing can take in Spring MVC. In this post I will show how to enforce such timeout through a custom  <a href=\"https://docs.oracle.com/cd/B14099_19/web.1012/b14017/filters.htm\">Servlet Filter</a>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 427px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1bdf737038c2292c9dc02e03db951a23/141dd/late.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 150%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAeABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAQFAgP/xAAVAQEBAAAAAAAAAAAAAAAAAAACAf/aAAwDAQACEAMQAAABqJNrl1TAhzUpKRMGyn//xAAdEAACAgIDAQAAAAAAAAAAAAACAwABBBEQEyIy/9oACAEBAAEFAskyFSbYlkevtm62Hw2vFEJGNaGXjhfH/8QAGBEAAwEBAAAAAAAAAAAAAAAAAQIQESH/2gAIAQMBAT8BCwNzJ//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPwFZk//EACAQAAEEAgEFAAAAAAAAAAAAAAIAARARITESAyJBYaH/2gAIAQEABj8C7dk9IR6hcmL5FaZvKxZe00MN5dVA1jjqo//EABwQAQEAAgMBAQAAAAAAAAAAAAERABAhMaFBUf/aAAgBAQABPyGScIX8udNW92tIczKaQ5iGeHLr3BOUFMnL5o6Fqpdc3X//2gAMAwEAAgADAAAAEGfeff/EABYRAQEBAAAAAAAAAAAAAAAAAAERAP/aAAgBAwEBPxCxkjMpha3f/8QAGBEBAQADAAAAAAAAAAAAAAAAAQAQESH/2gAIAQIBAT8Q0PIkLj//xAAgEAEBAAICAgIDAAAAAAAAAAABEQAhMUFRYRBxgaGx/9oACAEBAAE/ECQrry+36xo7nZKFGu44IlGmWVNmuR9YWKMWLcZ0/jPADTjAa8Hl13kpwy2gfzGeCjrEpHLy12CGh9c69/H/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Late request\"\n        title=\"Late request\"\n        src=\"/static/1bdf737038c2292c9dc02e03db951a23/141dd/late.jpg\"\n        srcset=\"/static/1bdf737038c2292c9dc02e03db951a23/a80bd/late.jpg 148w,\n/static/1bdf737038c2292c9dc02e03db951a23/1c91a/late.jpg 295w,\n/static/1bdf737038c2292c9dc02e03db951a23/141dd/late.jpg 427w\"\n        sizes=\"(max-width: 427px) 100vw, 427px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Request timeout Servlet Filter</h2>\n<p>Without further ado let us dive right into a sample filter implementation in Kotlin:</p>\n<pre><code class=\"language-kotlin\">@Component\n@Order(Ordered.HIGHEST_PRECEDENCE)\nclass TimeoutFilter : OncePerRequestFilter() {\n    override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) {\n        val completed = AtomicBoolean(false)\n        val requestHandlingThread = Thread.currentThread()\n        val timeout = timeoutsPool.schedule({\n            if (completed.compareAndSet(false, true)) {\n                requestHandlingThread.interrupt()\n            }\n        }, 5, TimeUnit.SECONDS)\n\n        try {\n            filterChain.doFilter(request, response)\n            timeout.cancel(false)\n        } finally {\n            completed.set(true)\n        }\n    }\n\n    companion object {\n        private val timeoutsPool = Executors.newScheduledThreadPool(10)\n    }\n\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    class TimeoutException(message: String) : java.util.concurrent.TimeoutException(message)\n}\n</code></pre>\n<p>The above code declares a Servlet Filter that will interrupt thread processing a request after 5 seconds. There are couple of interesting points about how it works.</p>\n<ul>\n<li><code>@Order(Ordered.HIGHEST_PRECEDENCE)</code> puts the Filter at the beginning of filter chain</li>\n<li><code>val completed = AtomicBoolean(false)</code> denotes whether the request processing completed. </li>\n<li><code>val timeoutsPool = Executors.newScheduledThreadPool(10)</code> creates a thread pool responsible for running timeouts. The <code>newScheduledThreadPool</code> creates a thread pool that is efficient at running delayed tasks.</li>\n<li><code>timeoutsPool.schedule({ ... })</code> schedules a code that will interrupt <code>requestHandlingThread</code> after 5 seconds</li>\n<li><code>completed.compareAndSet(false, true)</code> updates the <code>completed</code> flag in a thread safe fashion</li>\n</ul>\n<h2>Testing request timeout Servlet Filter</h2>\n<p>For the test purposes let us create a simple Spring Boot MVC application written in Kotlin:</p>\n<pre><code class=\"language-kotlin\">@SpringBootApplication\n@EnableWebMvc\nclass Application {\n    companion object {\n        @JvmStatic\n        fun main(args: Array&#x3C;String>) {\n            SpringApplication.run(Application::class.java)\n        }\n    }\n}\n\n@RestController\nclass TimeoutController {\n    @GetMapping(\"/timeout\")\n    fun timeout(@RequestParam(required = false) timeoutInMillis: Long?): ResponseEntity&#x3C;*> {\n        Thread.sleep(timeoutInMillis ?: 1000)\n        return ResponseEntity.ok(\"completed\")\n    }\n}\n</code></pre>\n<p>The <code>TimeoutController</code> will sleep for an amount of time given in a parameter. Let's simulate a short request with <a href=\"https://httpie.org/\"><code>httpie</code></a>:</p>\n<pre><code class=\"language-bash\">http :8080/timeout timeoutInMillis==2000\n\nHTTP/1.1 200 \nContent-Length: 9\nContent-Type: text/plain;charset=ISO-8859-1\nDate: Mon, 27 Nov 2017 12:19:03 GMT\n\ncompleted\n</code></pre>\n<p>This was the happy path. Now let's try a timeout path:</p>\n<pre><code class=\"language-bash\">http  :8080/timeout timeoutInMillis==6000       \n\nHTTP/1.1 500 \nConnection: close\nContent-Type: application/json;charset=UTF-8\nDate: Mon, 27 Nov 2017 12:21:30 GMT\nTransfer-Encoding: chunked\n\n{\n    \"error\": \"Internal Server Error\",\n    \"exception\": \"java.lang.InterruptedException\",\n    \"message\": \"sleep interrupted\",\n    \"path\": \"/timeout\",\n    \"status\": 500,\n    \"timestamp\": 1511785290518\n}\n</code></pre>\n<p>As you can see in the exception message, we see that the <code>Thread.sleep</code> in the controller action has been interrupted ðŸŽ‰</p>\n<h2>A word of warning</h2>\n<p>The above Servlet Filter will not work if we use <a href=\"https://docs.oracle.com/javaee/7/tutorial/servlets012.htm\">Async Servlet Filters</a>. When using Async Servlet Filter there is typically <strong>more than 1</strong> thread that handles a request hence the above approach will not work. Having said that if you use Async Servlet Filter there already is a way to apply a timeout that <a href=\"https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#setTimeout(long)\">is defined by the API</a>. Another important point is to check how the request processing thread pool handles interrupted threads. <a href=\"%25%20post_url%202017-11-21-spring-mvc-thread-pool-timeouts%20%25%7D\">As we have discussed earlier</a>, the concrete implementation of thread pool used to process request depends on servlet container and configured used in the application. We should make sure that the interrupted thread is eventually replaced with a new thread by the pool so that timeouts do not change the effective thread pool size.</p>","excerpt":"As we saw previously, we only have limited options to configure maximum time a request processing can take in Spring MVC. In this post Iâ€¦","frontmatter":{"slug":null,"title":"Request timeouts in Spring MVC","description":null,"author":"piotr","tags":["spring","mvc","spring-boot","request","timeout"],"date":"2017-11-27T23:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/1bdf737038c2292c9dc02e03db951a23/193e7/late.jpg","srcSet":"/static/1bdf737038c2292c9dc02e03db951a23/f6cea/late.jpg 107w,\n/static/1bdf737038c2292c9dc02e03db951a23/24ef2/late.jpg 214w,\n/static/1bdf737038c2292c9dc02e03db951a23/193e7/late.jpg 427w","sizes":"(min-width: 427px) 427px, 100vw"},"sources":[{"srcSet":"/static/1bdf737038c2292c9dc02e03db951a23/fd9c6/late.webp 107w,\n/static/1bdf737038c2292c9dc02e03db951a23/5ad86/late.webp 214w,\n/static/1bdf737038c2292c9dc02e03db951a23/6e434/late.webp 427w","type":"image/webp","sizes":"(min-width: 427px) 427px, 100vw"}]},"width":427,"height":640}}}},"timeToRead":3,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-11-28-spring-mvc-request-timeout.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-11-28-spring-mvc-request-timeout.md"}},"staticQueryHashes":["2189233960","3181594896"]}