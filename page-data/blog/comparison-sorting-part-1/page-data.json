{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/comparison-sorting-part-1","result":{"data":{"markdownRemark":{"html":"<p>Sorting data is one of the most important tasks that computers have been doing since they were invented. Over those years developers have found many ways of doing it. Some of these ways are quite fast, others involve  interesting methods and finally there are some which are practically useless, but still it is better to know more than to know less, so it’s better to learn them  in free time.</p>\n<p>For this series of blog posts I will divide sorting algorithms by their complexity:</p>\n<p><strong>Group 1:</strong> which average case complexity is n^2, like bubble, insertion sort</p>\n<p><strong>Group 2:</strong> which average case complexity is nlog(n), but worst is n^2, like quick, library sort</p>\n<p><strong>Group 3:</strong> which worst-case complexity is nlog(n), like merge, heap sorts</p>\n<p>Today I will show you a few examples from the first group. They are used mostly by beginners because they are the simplest ones. Unfortunately, there is a cost of their simplicity - long working time. N^2 complexity doesn’t sound bad when we talk about small data chunks like 100 elements - it’s just 10,000 operations. But when our program has to sort 1 million elements it takes 1 trillion of operations to do. Let’s move to real coding now. I’m going to use Kotlin, but it’s easy to translate every algorithm into other languages.</p>\n<h3>1) Bubble</h3>\n<p>A very simple algorithm, usually the first one that young programmer learns. Its idea is to compare each element with the next one and move bigger one to the right, which at the end of one loop finds the biggest element of an array. Then do it again and again excluding the elements that had been already found in the previous loops.</p>\n<pre><code class=\"language-kotlin\">fun bubbleSort(array: IntArray) {\n   var maxIndex = array.size-1\n   for(i in 0..maxIndex) {\n       for(j in 1..maxIndex) {\n           if(array[j-1] > array[j]) {\n               var temp = array[j-1]\n               array[j-1] = array[j]\n               array[j] = temp\n           }\n       }\n       maxIndex--\n   }\n}\n</code></pre>\n<h3>2) Insertion</h3>\n<p>Another basic algorithm. What it does is taking all elements one by one and putting them in the right place by comparing each  to every previously checked element.</p>\n<pre><code class=\"language-kotlin\">fun insertionSort(array: IntArray) {\n   val maxIndex = array.size-1\n   var j: Int\n   for(i in 1..maxIndex) {\n       var temp = array[i]\n       j = i - 1\n       while(j >= 0 &#x26;&#x26; array[j] > temp) {\n           array[j+1] = array[j]\n           j--\n       }\n       array[j+1] = temp\n   }\n}\n</code></pre>\n<h3>3) Selection</h3>\n<p>As its name suggests it selects the smallest element of the collection and puts it in the beginning. It repeats without previously found elements until our collection is sorted.</p>\n<pre><code class=\"language-kotlin\">fun selectionSort(array: IntArray) {\n   val maxIndex = array.size-1\n   var minimum: Int\n   var indexOfMinimum: Int\n   for(i in 0..maxIndex) {\n       minimum = array[i]\n       indexOfMinimum = i\n       for(j in i+1..maxIndex) {\n           if(array[j] &#x3C; minimum) {\n               minimum = array[j]\n               indexOfMinimum = j\n           }\n       }\n       if(i != indexOfMinimum) {\n           var temp = array[i]\n           array[i] = array[indexOfMinimum]\n           array[indexOfMinimum] = temp\n       }\n   }\n}\n</code></pre>\n<h3>4) Gnome</h3>\n<p>It’s like combining insertion with bubble sort. We check every element in a single loop and swap it with the previous one as long as it’s not in the right place.</p>\n<pre><code class=\"language-kotlin\">fun gnomeSort(array: IntArray) {\n   val maxIndex = array.size-1\n   var pos = 0\n   while(pos &#x3C; maxIndex) {\n       if(pos == 0 || array[pos] >= array[pos-1]){\n           pos++\n       } else {\n           var temp = array[pos]\n           array[pos] = array[pos - 1]\n           array[pos - 1] = temp\n           pos--\n       }\n   }\n}\n</code></pre>\n<h3>5) Cocktail</h3>\n<p>It’s also called bidirectional bubble sort - going forward it compares elements looking for the the biggest one and going backward it seeks the smallest one.</p>\n<pre><code class=\"language-kotlin\">fun cocktailSort(array: IntArray) {\n   var maxIndex = array.size-1\n   for(i in 0..maxIndex) {\n       for(j in 1..maxIndex) {\n           if(array[j-1] > array[j]) {\n               var temp = array[j-1]\n               array[j-1] = array[j]\n               array[j] = temp\n           }\n       }\n       for(g in maxIndex downTo 1) {\n           if(array[g-1] > array[g]) {\n               var temp = array[g-1]\n               array[g-1] = array[g]\n               array[g] = temp\n           }\n       }\n       maxIndex--\n   }\n}\n</code></pre>\n<p>So, now when we’re done with the code, let’s look at the results.</p>\n<p><strong>Sample #1:</strong> 100 arrays of 1000 integer numbers:</p>\n<pre><code>Avg of bubble sort: 1.59\nAvg of insertion sort: 0.18\nAvg of selection sort: 0.38\nAvg of gnome sort: 1.08\nAvg of cocktail sort: 1.65\n</code></pre>\n<p><strong>Sample #2:</strong> 100 arrays of 10000 integer numbers:</p>\n<pre><code>Avg of bubble sort: 156.39\nAvg of insertion sort: 13.01\nAvg of selection sort: 30.25\nAvg of gnome sort: 104.22\nAvg of cocktail sort: 169.53\n</code></pre>\n<p>Increasing the amount of data 10 times has caused these time multiplications: </p>\n<pre><code>Bubble: ~98 times longer\nInsertion: ~72 times longer\nSelection: ~79 times longer\nGnome: ~97 times longer\nCocktail: ~103 times longer\n</code></pre>\n<p>As we can see for all algorithms increasing the amount of data 10 times has caused time to increase around 100 times, which confirms that their complexity is n^2. Insertion and selection sorts are a little bit better, but it’s still n^2, so we should use it as a last resort.</p>\n<p>That’s all for this part. Soon I will prepare the comparison of algorithms from group 2.</p>\n<p><strong>PS.</strong> This post has assured me of one thing - Internet lies. Most sources say that comb sort average- and worst-case complexity is n^2, but my tests prove different. After a long research I have even found a book which says about nlog(n) complexity. You could read more about that soon. </p>","excerpt":"Sorting data is one of the most important tasks that computers have been doing since they were invented. Over those years developers have…","frontmatter":{"slug":null,"title":"Comparison sorting part 1","description":null,"author":"grzesiek","tags":["sorting","algorithm","bubble","insertion","selection","gnome","cocktail"],"date":"2018-01-17T23:00:00.000Z","image":null},"timeToRead":4,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-18-comparison-sorting-part-1.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-18-comparison-sorting-part-1.md"}},"staticQueryHashes":["2189233960","3181594896"]}