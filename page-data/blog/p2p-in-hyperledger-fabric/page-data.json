{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/p2p-in-hyperledger-fabric","result":{"data":{"markdownRemark":{"html":"<p>Due to the modular and plug-and-play architecture hyperledger fabric implements a peer-to-peer protocol based on <strong>gRPC and proto buffers</strong> which allows for bi-directional stream-based messaging. We will examine the individual elements of the protocol and the examples of messages sent in the Hyperlegder network.</p>\n<h2>gRPC basics</h2>\n<p><strong>gRPC</strong> is an alternative to <strong>REST</strong> and other RPC frameworks, based on HTTPS 2.0 which is faster and has improved security features over HTTPS 1.1.</p>\n<p>Like many RPC systems, <strong>gRPC</strong> is based on the idea of defining a service and specifying the methods that can be called remotely. In <strong>gRPC</strong> a client application can directly call methods on a server application on a different machine as if it was a local object, making it easier for you to create distributed applications and services.</p>\n<pre><code class=\"language-bash\">service HelloService {\n  rpc SayHello (HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n  string greeting = 1;\n}\n\nmessage HelloResponse {\n  string reply = 1;\n}\n</code></pre>\n<p>On the server side, the server implements interface and runs a <strong>gRPC</strong> server to handle the client calls. On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0646e5ab1fd87419ea82826af988223e/4c42d/grcp-graph.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACg0lEQVQoz4WT+0tTYRzG97fU/1AR/RgkCWXiJU2ndDPSCIny0g9dNAKpyJSsEBWRxAveptvUlTcUDFPxUm7TOXZYefS4qZtnZ7btE+c1RSPpgYeXly/f5/1entfAAcRisUOnDml1lZklF1MOJ0teL4rPx+LqGimvyokrLCah8h1ZJitJze2Ujoxh0JMjkeguo1F+RSJEYzEh6pQkHB4PG4HgfkxVVeZ//CTx8VPic3OJL3tJVnevECwZHsPAEVj2evEHAv+MLa7IpFXXkfChhrTGVoydZpJbOijVBRfWFMptA1TaPgtWDQzxqLWNCbdHJKuaRjAUwqsozLmWxUOzHokbPX2kd1rI6Ogho81EYnM7T4ZGMXTNzHE8KYUz165zIjubk1nZHEtOpX5klM1AALtHYs7lwu7xsOLz6QPGr4W5Y+knz9xHgW2QB7ZBrnZZKBsdx2BdsHP63n3OFRZztqCIuKJiTt3N53W3GbfXi+zzsfFX6/qMfWqI9W2VdVVnCGVbZUsLY7C53KS2mcjsNIvyjV0WLtY3Yv1u39/y/PIyk3aHOPUHwjs7bO7ssK6FRbVCXA0RDIcxmJ1LnP/YIuag09jRI+7vh0fRQqH9qrY1Ddnvx7+1xZwkYax4S1LJM9Kra7llsZHZ3s2LsS8Yvq0qvBn/Ss3UDLXTs9RNz1I+PsGsvIZXlnFI0qGWNU1jyu0mvvghcTk5xD0vI9Nk5VJT2+5S+A88siy2O+10MulwICsKLkXB2NDIhYoqLjc0HbaNMHY0SiQWE8OO/rnvmXvv5+gt69ShqCFyzP1c6bIIMb3d5JbOo419UOjgN9yDHAyS3/uJ2z195Jn7BW+arMI2vwHXty/LgOTsfgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Grpc graph\"\n        title=\"Grpc graph\"\n        src=\"/static/0646e5ab1fd87419ea82826af988223e/fcda8/grcp-graph.png\"\n        srcset=\"/static/0646e5ab1fd87419ea82826af988223e/12f09/grcp-graph.png 148w,\n/static/0646e5ab1fd87419ea82826af988223e/e4a3f/grcp-graph.png 295w,\n/static/0646e5ab1fd87419ea82826af988223e/fcda8/grcp-graph.png 590w,\n/static/0646e5ab1fd87419ea82826af988223e/efc66/grcp-graph.png 885w,\n/static/0646e5ab1fd87419ea82826af988223e/4c42d/grcp-graph.png 896w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Due to the fact that <strong>gRCP</strong> uses <strong>proto buffers</strong>, the server may be written in a different language than the client (for now it supports 10 programming languages).</p>\n<h2>Proto buffers</h2>\n<p><strong>Protocol buffers</strong> are Google's language-neutral, platform-neutral, extensible mechanisms for serialising structured data.</p>\n<p>To better understand how proto buffers work, let's compare it with <strong>JSON</strong>:</p>\n<pre><code class=\"language-bash\">{\"name\":\"Peter\",\"lastName\":\"Jason\"}\n</code></pre>\n<p>This <strong>JSON</strong> object contains 35 characters, 25 of these including { : \" \" , } are informative and the actual message you send contains only 10 characters.</p>\n<p>Let's now implement the same message using proto buffers:</p>\n<pre><code class=\"language-bash\">syntax = \"proto3\";\n\nmessage Identity {\n    string name = 1; \n    string lastName = 2;\n}\n</code></pre>\n<p>This is our simple proto file in which we have defined Identity message. Now let's generate js protobuf classes:</p>\n<pre><code class=\"language-bash\">protoc --js_out=import_style=commonjs,binary:. identity.proto\n</code></pre>\n<p>This will provide simple accessors for each field (like <code>name()</code> and <code>setName()</code>) as well as methods to serialize/parse the whole structure to/from raw bytes.</p>\n<pre><code class=\"language-bash\">// Serialization\n\nvar msg = new pb.Identity()\n\nmsg.setName(\"Peter\")\nmsg.setLastname(\"Jason\")\n\nconst bytes = msg.serializeBinary()\nconsole.log(bytes)\n</code></pre>\n<p>After the serialisation, our 14 bytes long message in <code>UInt8Array</code> format might become the content of our <strong>gRPC</strong> request.</p>\n<pre><code class=\"language-bash\">10 5 80 101 116 101 114 18 5 74 97 115 111 110\n</code></pre>\n<h2>Usage in Hyperledger</h2>\n<p>Now, that we have some basic knowledge of <strong>gRPC and proto buffers</strong>, we can examine how Hyperledger distributes the changes made in our chaincode asset.</p>\n<p>Let's consider createCar function from <code>fabcar</code> chaincode:</p>\n<pre><code class=\"language-bash\">async createCar(ctx, carNumber, make, model, color, owner) {\n    console.info('============= START : Create Car ===========');\n\n    const car = {\n        color,\n        docType: 'car',\n        make,\n        model,\n        owner,\n    }\n\n    await ctx.stub.putState(carNumber,       Buffer.from(JSON.stringify(car)));\n    console.info('============= END : Create Car ===========');\n}\n</code></pre>\n<p>In the end we call <code>ctx.stub.putState</code> function. Let's take a closer look into how this function inserts a new car asset into the world state.</p>\n<p>We are passing two arguments, record <code>key</code> and <code>Buffer</code>, which contain our car asset.</p>\n<p>Inside the function Hyperledger uses <code>putState</code> proto buffer message with key, value and collection field.</p>\n<pre><code class=\"language-bash\">// PutState is the payload of a ChaincodeMessage. It contains a key and value\n// which needs to be written to the transactions write set. If the collection is\n// specified, the key and value would be written to the transactions private\n// write set.\nmessage PutState {\n   string key = 1;\n   bytes value = 2;\n   string collection = 3;\n}\n</code></pre>\n<p>Next it generates js protobuf class, and sets our key and value as payload parameters, which is the part of <code>putState</code> message. We can see that we also have to specify <code>transactionId</code> and channel that we are targeting.</p>\n<pre><code class=\"language-bash\">async handlePutState(collection, key, value, channel_id, txId) {\n    const payload = new _serviceProto.PutState();\n    payload.setKey(key);\n    payload.setValue(value);\n    payload.setCollection(collection);\n\n    const msg = {\n        type: _serviceProto.ChaincodeMessage.Type.PUT_STATE,\n        payload: payload.toBuffer(),\n        txid: txId,\n        channel_id: channel_id\n    };\n\n    return await this._askPeerAndListen(msg, 'PutState');\n}  \n</code></pre>\n<p>This message is sent via <strong>gRPC</strong> request to the defined peers in our connection profile, and now we can start listening to the proposal responses!</p>","excerpt":"Due to the modular and plug-and-play architecture hyperledger fabric implements a peer-to-peer protocol based on gRPC and proto buffers…","frontmatter":{"slug":null,"title":"P2P in Hyperledger Fabric","description":null,"author":"tomek","tags":["blockchain","grpc","hyperledger","blog"],"date":"2020-02-14T15:21:07.486Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/465ef554cd13de480d8993610aacfae4/a6312/tomek-p2p-in-hyperledger.png","srcSet":"/static/465ef554cd13de480d8993610aacfae4/e20c6/tomek-p2p-in-hyperledger.png 300w,\n/static/465ef554cd13de480d8993610aacfae4/62ea7/tomek-p2p-in-hyperledger.png 600w,\n/static/465ef554cd13de480d8993610aacfae4/a6312/tomek-p2p-in-hyperledger.png 1200w","sizes":"(min-width: 1200px) 1200px, 100vw"},"sources":[{"srcSet":"/static/465ef554cd13de480d8993610aacfae4/b979a/tomek-p2p-in-hyperledger.webp 300w,\n/static/465ef554cd13de480d8993610aacfae4/2fa07/tomek-p2p-in-hyperledger.webp 600w,\n/static/465ef554cd13de480d8993610aacfae4/f9756/tomek-p2p-in-hyperledger.webp 1200w","type":"image/webp","sizes":"(min-width: 1200px) 1200px, 100vw"}]},"width":1200,"height":600}}}},"timeToRead":3,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-02-14-p2p-in-hyperledger-fabric.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-02-14-p2p-in-hyperledger-fabric.md"}},"staticQueryHashes":["2189233960","3181594896"]}