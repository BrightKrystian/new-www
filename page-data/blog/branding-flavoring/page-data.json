{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/branding-flavoring","result":{"data":{"markdownRemark":{"html":"<h3>Introduction</h3>\n<p>TypeScript language mainly uses structural typing. In structural typing, an element is considered to be compatible\nwith another if, for each feature within the second element's type, a corresponding and identical feature exists in the\nfirst element's type. Sometimes this behavior may allow us to write erroneous code. </p>\n<h3>Example</h3>\n<p>Let's imagine a function which calculates candy price based on their weight and price per unit:</p>\n<pre><code class=\"language-typescript\">// Create a type for our candy\ntype Candy = {\n  pricePerUnit: number\n  weight: number\n}\n\n// Create a function from our example\nconst calculateCandyPrice = (candy: Candy) => candy.pricePerUnit * candy.weight\n\n// Create a type with similar structure to type Candy\ntype Veggie = {\n  pricePerUnit: number\n  weight: number\n}\n\n// Declare variables based on our types\ndeclare const candyDrops: Candy\ndeclare const broccolis: Veggie\n\n// Is this function safely typed? \ncalculateCandyPrice(candyDrops)                          // OK \ncalculateCandyPrice({ pricePerUnit: 1000, weight: 20 })  // OK \ncalculateCandyPrice(broccolis)                           // OK \n</code></pre>\n<p>TypeScript compiler does not throw an error, even though we as programmes see that this behavior may not be desired.\nThis problem can be solved by nominal typing. Nominal typing means that two variables are type-compatible if and only if\ntheir declarations name the same type. TypeScript unfortunately does not have such a syntax feature. There are some\nmethods which we can use to omit that problem. </p>\n<h3>Branding</h3>\n<p>Branding concept is a technique in which we add a unique field which will make our type differ from another types.\nWhat is important we do not need to assign any value there because it only exists for TypeScript compiler. </p>\n<pre><code class=\"language-typescript\">type Candy = {\n  __brand: \"Candy\"\n  pricePerUnit: number\n  weight: number\n}\n\ntype Veggie = {\n  __brand: \"Veggie\"\n  pricePerUnit: number\n  weight: number\n}\n\nconst calculateCandyPrice = (candy: Candy) => candy.pricePerUnit * candy.weight\n\ndeclare const candyDrops: Candy\ndeclare const broccolis: Veggie\n\ncalculateCandyPrice(candyDrops)                          // OK \ncalculateCandyPrice({ pricePerUnit: 1000, weight: 20 })  // Error\ncalculateCandyPrice(broccolis)                           // Error\n</code></pre>\n<p>We can also create generic type for our branding: </p>\n<pre><code class=\"language-typescript\">type Brand&#x3C;T, BrandT> = T &#x26; { __brand: BrandT }\n\n// Similar type as before\ntype Candy = Brand&#x3C;{ pricePerUnit: number, weight: number }, \"Candy\">\n</code></pre>\n<p>Changing primitive value to branded value requires manual casting:</p>\n<pre><code class=\"language-typescript\">type CandyID = Brand&#x3C;string, \"CandyID\">\n\nconst candyId = \"some-long-id\" as CandyID // Brand&#x3C;string, \"CandyID\">\n</code></pre>\n<p>To make our code cleaner we can use these helpers to change our type to be nominal or reversed: </p>\n<pre><code class=\"language-typescript\">const toCandyID = (id: string) => id as CandyID\nconst fromCandyID = (id: CandyID) => id as string\n\nconst candyIdTo = toCandyID('some-long-id-1') // Brand&#x3C;string, \"CandyID\">\nconst candyIdFrom = fromCandyID(candyIdTo)    // string\n</code></pre>\n<p>Bear in mind that branding has got two cons:</p>\n<ol>\n<li>\n<p>Compiler allow us to read <code>__brand</code> property</p>\n<pre><code class=\"language-typescript\">const brandProperty = candyDrops.__brand // OK \n</code></pre>\n</li>\n<li>\n<p>A raw object passed to the function as an argument stopped working</p>\n<pre><code class=\"language-typescript\">calculateCandyPrice({ pricePerUnit: 1000, weight: 20 })  // Error\n</code></pre>\n</li>\n</ol>\n<h3>Flavoring</h3>\n<p>Flavoring concept is a technique in which we add a unique <strong>optional</strong> field which will make our type differ from another\ntypes. This difference between <em>branding</em> and <em>flavoring</em> allow us to pass a raw object as an argument to the function.\nUnfortunately we still can access <code>__flavor</code> property.</p>\n<pre><code class=\"language-typescript\">type Candy = {\n  __flavor?: \"Candy\"\n  pricePerUnit: number\n  weight: number\n}\n\ntype Veggie = {\n  __flavor?: \"Veggie\"\n  pricePerUnit: number\n  weight: number\n}\n\nconst calculateCandyPrice = (candy: Candy) => candy.pricePerUnit * candy.weight\n\ndeclare const candyDrops: Candy\ndeclare const broccolis: Veggie\n\ncalculateCandyPrice(candyDrops)                          // OK \ncalculateCandyPrice({ pricePerUnit: 1000, weight: 20 })  // OK\ncalculateCandyPrice(broccolis)                           // Error\n</code></pre>\n<p>We can also create generic type for our flavoring:</p>\n<pre><code class=\"language-typescript\">type Flavor&#x3C;T, FlavorT> = T &#x26; { __flavor?: FlavorT }\n\n// Similar type as before\ntype Veggie = Flavor&#x3C;{ pricePerUnit: number, weight: number }, \"Veggie\">\n</code></pre>\n<p>We do not need to cast primitive values manually using this technique.</p>\n<h3>Conclusion</h3>\n<p>To sum up those two techniques - it is commonly used that if we use <em>branding</em> and <em>flavoring</em> we use <em>branding</em> for\nprimitive types while <em>flavoring</em> for objects. We can use\n<a href=\"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\">conditional type</a> for that:</p>\n<pre><code class=\"language-typescript\">type Nominal&#x3C;T, NameT> = T extends object ? Flavor&#x3C;T, NameT> : Brand&#x3C;T, NameT>\n</code></pre>\n<p>Alternatively we can use other more sophisticated techniques to achieve nominal typing or libraries such as:\n<a href=\"https://github.com/gcanti/newtype-ts\">newtype-ts</a> or <a href=\"https://github.com/gcanti/io-ts\">io-ts</a>.</p>","excerpt":"Introduction TypeScript language mainly uses structural typing. In structural typing, an element is considered to be compatible \nwithâ€¦","frontmatter":{"slug":null,"title":"Branding & Flavoring","description":null,"author":"wojciech","tags":["typescript","types","candies","veggies"],"date":"2021-01-08T12:12:12.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/1bb55ab28d1fafb7668c023696f0709a/c7636/branding_and_flavoring.png","srcSet":"/static/1bb55ab28d1fafb7668c023696f0709a/1aa8f/branding_and_flavoring.png 175w,\n/static/1bb55ab28d1fafb7668c023696f0709a/65f9b/branding_and_flavoring.png 350w,\n/static/1bb55ab28d1fafb7668c023696f0709a/c7636/branding_and_flavoring.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/1bb55ab28d1fafb7668c023696f0709a/8b01d/branding_and_flavoring.webp 175w,\n/static/1bb55ab28d1fafb7668c023696f0709a/e8f67/branding_and_flavoring.webp 350w,\n/static/1bb55ab28d1fafb7668c023696f0709a/912fb/branding_and_flavoring.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":277}}}},"timeToRead":3,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2021-01-08-branding-flavoring.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2021-01-08-branding-flavoring.md"}},"staticQueryHashes":["2189233960","3181594896"]}