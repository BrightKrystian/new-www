{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/5-ways-to-benefit-from-typescript-in-react","result":{"data":{"markdownRemark":{"html":"<p>In the <a href=\"https://brightinventions.pl/blog/modern-way-getting-started-react-typescript/\">recent post</a> we discussed how we can start a new React project with TypeScript to benefit from all the goodies of type checks and eliminate the whole class of errors and typos from our codebase. Now let’s see how we can apply TypeScript-based type definitions into our React project to get most of it.</p>\n<p>To get started, as with every library we want to have the TypeScript support for, we need to grab the type definitions first. As usual, the way to do it is using the <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">DefinitelyTyped</a> project and run:</p>\n<pre><code class=\"language-bash\">npm install --save-dev @types/react @types/react-dom\n</code></pre>\n<h2>The basics – Components</h2>\n<p>The components in React are in most cases ES6 classes that extend React-provided <code>Component</code> class. TypeScript is adding two generic arguments to this base class definition – the first one defines what our props are and the second is for the local component’s state.</p>\n<pre><code class=\"language-typescript\">interface HelloProps {\n    greeting: string\n}\n\ninterface HelloState {\n    wasDisplayed: boolean\n}\n\nclass HelloWorldComponent extends React.Component&#x3C;HelloProps, HelloState> {}\n</code></pre>\n<p>By adding these two definitions we’re not only adding a code completion capability to our component. Here I denoted I expect a <code>greeting</code> property and marked it as non-optional (no <code>?</code> sign before a colon and no union type that allows <code>undefined</code> to sneak through). The compiler now successfully prevents us from using this component without the proper <code>greeting</code> property passed in.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1ad810b45f0392bd755f7aaa036a276c/6da96/props-undefined.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 11.486486486486488%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAZElEQVQI11XNSQ6AIBBEUY9mhGYUWxxR7n+OMmFYuKi85G9qmDnCBUbwFtfByM+GnCJWXmCchyCFSVJRUFUqXVrv3XESGMK640wv9ivVnQnxuMuJXxhkHKS2RTK2zf26bF0ogw+VY0q0jNcGtAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Props completeness is enforced\"\n        title=\"Props completeness is enforced\"\n        src=\"/static/1ad810b45f0392bd755f7aaa036a276c/fcda8/props-undefined.png\"\n        srcset=\"/static/1ad810b45f0392bd755f7aaa036a276c/12f09/props-undefined.png 148w,\n/static/1ad810b45f0392bd755f7aaa036a276c/e4a3f/props-undefined.png 295w,\n/static/1ad810b45f0392bd755f7aaa036a276c/fcda8/props-undefined.png 590w,\n/static/1ad810b45f0392bd755f7aaa036a276c/efc66/props-undefined.png 885w,\n/static/1ad810b45f0392bd755f7aaa036a276c/6da96/props-undefined.png 922w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>Props &#x26; state (im)mutability</h3>\n<p>But there’s more. In React, both props and state are intended to be immutable. Props are for getting the data into the component only and state is to be modified via the specialized <code>setState</code> method. Thanks to both props and state defined as being of type <code>Readonly&#x3C;></code>, we are protected from accidentally mutating it:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 544px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2aa6775781ed8b57ab970c8590174140/b3e51/props-immutable.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.567567567567565%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQY02WNbW6DMBAFOVFtKLYDBHAIkaw0rRsc83X/e0wVlESq8mM07612tcnBWT6kpG80i6+J54rp2xIvDX1nMaYky1LSLCX7vFsihEBKgRTvJM3Joo1mVxQ4a/B9xalzuKPj3Dku/Rd13VK1Je2xptgX5LlCqSd6c/7ISZxXbtPMECeGcSGMMz/XQJyXjTBOm39DxF8DQxwZ5xU/BPxwe+1s82UlKQ979M5sX7TWD8zLSut31P/8vLv3P6TWi6qksV+mAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Props immutability is enforced\"\n        title=\"Props immutability is enforced\"\n        src=\"/static/2aa6775781ed8b57ab970c8590174140/b3e51/props-immutable.png\"\n        srcset=\"/static/2aa6775781ed8b57ab970c8590174140/12f09/props-immutable.png 148w,\n/static/2aa6775781ed8b57ab970c8590174140/e4a3f/props-immutable.png 295w,\n/static/2aa6775781ed8b57ab970c8590174140/b3e51/props-immutable.png 544w\"\n        sizes=\"(max-width: 544px) 100vw, 544px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>￼</p>\n<p>As well as we’re not allowed to monkey-patch it, that is to add new properties there:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 456px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/433a099581c3d55d43bf0e8f514a937e/7f664/props-frozen.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.27027027027027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxUlEQVQY04WM2W6DMAAE+SVACocNhMMcRQ0EY2NI+v+fMVWoktc+jGalXa3XtANlq7i2BZcopMwuzL1gaBJunThzdZVEcYLv+//iVY0ilYIoT5jGgvqaMqkYN7wOO5avnvl7RKmOOI2QZYrIY8IwJAiCj9/Za4cRdzzZnz9M2rC6B7e7Rq+GWVu0cczLyrYf3FeDthZtN6zbMZtjWS3b8TjRxuJVqqNWPfXQIoscmf0hZHYis4xUSMTLUn76k/ztgiwvzs0vma6OMaeGv4sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Props are frozen\"\n        title=\"Props are frozen\"\n        src=\"/static/433a099581c3d55d43bf0e8f514a937e/7f664/props-frozen.png\"\n        srcset=\"/static/433a099581c3d55d43bf0e8f514a937e/12f09/props-frozen.png 148w,\n/static/433a099581c3d55d43bf0e8f514a937e/e4a3f/props-frozen.png 295w,\n/static/433a099581c3d55d43bf0e8f514a937e/7f664/props-frozen.png 456w\"\n        sizes=\"(max-width: 456px) 100vw, 456px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>￼</p>\n<p>Having said that, we must be aware that <code>Readonly&#x3C;></code> is not deep (recursive) – it only protects us from mutating the root level of the object, nothing protects its children objects:</p>\n<pre><code class=\"language-typescript\">interface State {\n    inner: {stuff: string}\n}\n\n// this is still possible\nthis.state.inner.stuff = \"inner’s properties are still mutable\"\n</code></pre>\n<p>Until React's typings implement the proper support for deep Readonly (<a href=\"https://github.com/Microsoft/TypeScript/pull/21316\">which is possible starting from TypeScript 2.8</a>), the best we can (and should) do is to ensure on our own that all the properties of both props and state of our components are also marked as <code>Readonly&#x3C;></code> (as well as its inner properties, ad infinitum):</p>\n<pre><code class=\"language-typescript\">interface State {\n    inner: Readonly&#x3C;{stuff: string}>\n}\n\n// now we’re safe again\nthis.state.inner.stuff = \"this does not compile anymore\"\n</code></pre>\n<h3><code>setState</code> correctness</h3>\n<p>Another class of errors we’re automatically protected from is when we call <code>setState</code> with an invalid object. The first parameter of this function is defined with a rather cryptic type declaration:</p>\n<pre><code class=\"language-typescript\">state: ((prevState: Readonly&#x3C;S>, props: P) => (Pick&#x3C;S, K> | S | null)) | (Pick&#x3C;S, K> | S | null),\n</code></pre>\n<p>But when reading piece by piece it tells us we either need to pass a function that returns <code>Pick&#x3C;S, K> | S | null</code> or return it directly. And that <code>Pick&#x3C;S, K> | S | null</code> thing is – reading backwards – either <code>null</code>, full state object itself (<code>S</code>) or an object with a subset of the state’s keys (<a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types\"><code>Pick&#x3C;S, K></code></a>). To cut the long story short, we are unable to pass the new state value object that doesn’t match our state definition. Here is the error that the TypeScript compiler gives us instead:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/627471db37f4f586e0f2c1b065c4f2b7/19a6b/state-correctness.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 8.783783783783782%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAZUlEQVQI11WLSw7CMAwFeyenEqRQFiwr0cSf3P8mg2J1AYvR83sjL8e7osfOa3+y3R7Ue6WsKyKClJKUK/+6/OzXPVk+TenudHPUB92C7kFT4+zGqYbFyD69eqAx0jWL9JP8j8EXrGFIBkgppe4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"State correctness is enforced\"\n        title=\"State correctness is enforced\"\n        src=\"/static/627471db37f4f586e0f2c1b065c4f2b7/fcda8/state-correctness.png\"\n        srcset=\"/static/627471db37f4f586e0f2c1b065c4f2b7/12f09/state-correctness.png 148w,\n/static/627471db37f4f586e0f2c1b065c4f2b7/e4a3f/state-correctness.png 295w,\n/static/627471db37f4f586e0f2c1b065c4f2b7/fcda8/state-correctness.png 590w,\n/static/627471db37f4f586e0f2c1b065c4f2b7/efc66/state-correctness.png 885w,\n/static/627471db37f4f586e0f2c1b065c4f2b7/c83ae/state-correctness.png 1180w,\n/static/627471db37f4f586e0f2c1b065c4f2b7/19a6b/state-correctness.png 1191w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>￼￼</p>\n<h2>Stateless components</h2>\n<p>Seasoned React developers are probably familiar with the simplest form of components available – <a href=\"https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc\">stateless functional components</a>. These are defined as pure functions that receive the props and return an JSX element. As simple as that, from the typing perspective it is usually  sufficient to treat it like any other function – specifying types of its parameters and optionally the return type:</p>\n<pre><code class=\"language-typescript\">interface InputProps {\n    value: any\n    onChanged: () => void\n}\n\nfunction Input(props: InputProps) {\n    return &#x3C;input type=\"text\" onChange={props.onChanged} value={props.value}/>\n}\n</code></pre>\n<p>We can have a problem here, though, if we want to specify <code>propTypes</code> or <code>defaultProps</code> for our stateless component. TypeScript will complain as plain functions do not have that kind of properties defined:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 559px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ff81ece96bd18390eeff527687ca7c9d/a65ce/propTypes.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.972972972972975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDUlEQVQY0zWP226DMBBE+aBioqQBbAM2GIdryKWhaqJK/f+vOFXc9GE0u2c1Gm0kC4uxlsVsWN2O26hZL57puOB8RzdPdONIPx4xxpBLhdIFWSpRmUZmmjyXKK2QShPJoqIoDWW2x+WCItvgbIqpdCjKdUauMoytaZyjNIbKNihZUqmaSlm0LqiMoTSWaLtPaaxmHSrSXFPXLTLXbHfvCCFIRBJcxDFxHCNEHOYkEcTib0+S5HV/I7reVk4fZx73K7f1k8f3D1/3B8v5Et7ux4l5OTGME8M0M87HF58Df+rQD4E/M9G0nGmHHus81jlM3dC0nsa1OO+pgx+onQv+rydv/YH20GEbFzK+6/kFssavZ76g5NYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"PropTypes cannot be added to plain function\"\n        title=\"PropTypes cannot be added to plain function\"\n        src=\"/static/ff81ece96bd18390eeff527687ca7c9d/a65ce/propTypes.png\"\n        srcset=\"/static/ff81ece96bd18390eeff527687ca7c9d/12f09/propTypes.png 148w,\n/static/ff81ece96bd18390eeff527687ca7c9d/e4a3f/propTypes.png 295w,\n/static/ff81ece96bd18390eeff527687ca7c9d/a65ce/propTypes.png 559w\"\n        sizes=\"(max-width: 559px) 100vw, 559px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>￼￼</p>\n<p>We can solve it by declaring our component in a slightly different manner:</p>\n<pre><code class=\"language-typescript\">const Input: React.StatelessComponent&#x3C;InputProps> = function (props) {\n    return &#x3C;input type=\"text\" onChange={props.onChanged} value={props.value}/>\n}\n\nInput.propTypes = {\n    value: PropTypes.any.isRequired\n}\n</code></pre>\n<p>But let’s stop and think for a moment what we’re trying to achieve here. Doesn’t TypeScript give us a similar level of type safety with much more convenience already? I find <a href=\"https://dbushell.com/2017/04/19/typescript-instead-of-react-proptypes/\">using PropTypes not needed anymore</a> at all.</p>\n<h2>Events</h2>\n<p>Our next stop in the React world that might make use of stronger typing is around Events system. We take care of events every time we want our component to react to user actions. Let’s see our simplistic <code>Input</code> component once again:</p>\n<pre><code class=\"language-typescript\">interface InputProps {\n    value: any\n    onChanged: () => void\n}\n\nfunction Input(props: InputProps) {\n    return &#x3C;input type=\"text\" onChange={props.onChanged} value={props.value}/>\n}\n</code></pre>\n<p>The <code>onChange</code> property, as every event handler, takes an event object as the only parameter. Let’s express it in our <code>InputProps</code> interface definition. <code>Event</code> is a name defined by the HTML spec itself, so let’s first try using it here:</p>\n<pre><code class=\"language-typescript\">onChanged: (event: Event) => void\n</code></pre>\n<p>Unfortunately, this seems to be not the event we should care about:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.972972972972975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9klEQVQY043O226CQBSFYV5JmSaKxTqDoo4UgTkAVm2rNbTv/wB/A22aeNeLLytrJztZwVJKUvVMrHImyiAmCePxmNFodKe//Ucwn01JZYxMVsRyxUKtmEUzokkvYhpFQz4IcfcYhiFCiB+h+OuB9x7vKuq2oWlbnK/ZFxVlZSlKg3Eeaz1FZSitozSOwljysmKtd6x1NmS61Wx0RnDtvni/dbxeb1xuHdfuk/Plg8P5jeZ4on454Q9HbHOgdDV749B5Qaozltsdy82v7Y5kown2lcH6Gle3WN9Q9MuMHRblRYXOcp5Uwlz2FI9PknjRU0O/s1B8AwljtacrJGnvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"React does not use native HTML events\"\n        title=\"React does not use native HTML events\"\n        src=\"/static/60d4d6a38f5905748b688c07cfd1eb1d/fcda8/event-native.png\"\n        srcset=\"/static/60d4d6a38f5905748b688c07cfd1eb1d/12f09/event-native.png 148w,\n/static/60d4d6a38f5905748b688c07cfd1eb1d/e4a3f/event-native.png 295w,\n/static/60d4d6a38f5905748b688c07cfd1eb1d/fcda8/event-native.png 590w,\n/static/60d4d6a38f5905748b688c07cfd1eb1d/efc66/event-native.png 885w,\n/static/60d4d6a38f5905748b688c07cfd1eb1d/c83ae/event-native.png 1180w,\n/static/60d4d6a38f5905748b688c07cfd1eb1d/7798c/event-native.png 1183w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>￼￼\n￼\nThis rather verbose error gives us the expected type of an event, above anything else – see its last line. The event object passed by React is actually typed as <code>ChangeEvent&#x3C;HTMLInputElement></code> and this type seems not to extend the HTML built-in <code>Event</code> type. This is intentional because React doesn’t use the HTML events directly – it uses <a href=\"https://reactjs.org/docs/events.html\">Synthetic Events</a> wrappers instead.</p>\n<p>When we change our <code>Event</code> type definition to the synthetic event type determined by both event type and element type, we are fine:</p>\n<pre><code class=\"language-typescript\">onChanged: (event: React.ChangeEvent&#x3C;HTMLInputElement>) => void\n</code></pre>\n<p>This gives us the best possible confidence level for what we can expect to get as an argument. It horribly reduces the flexibility, though. We can no longer have the same change handler for events fired on multiple types of HTML Elements (for example, <code>&#x3C;input></code> and <code>&#x3C;select></code>:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/27ddaa858d4e9c58bb4eaf90f29b0426/08037/event-incompatible.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.972972972972975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9ElEQVQY022OWXKCQBRF2ZAY0BJBMJGpGwSizBI+Ykb3v4GTohPLSiUfp8699+c9zXNtQtdm63nYjsvKWmPZtvJqaWIYxh9M8/99QnPWS3zXwtk42M4Gy1qzMBeYE4bB3XyOruvo+uzbs9mvPlf5Zk2mkqbKGMaOfjhRVS1JkiGSlDQrkDIliCJiIYliQSwThZAJQRTjByF+GLELQtW1l/cL54m3T14/LozPZ7qnkXYYafqBuh9oT6Ny1Z04Nh15WZMfK9LigJiOZgViXyDzR7RDVdN0PWXdUjbtT27Y54X6JIwloZDc+wHbna/wHiZ2ytftyhdhXLIH9G7QZgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Events on different HTML elements are not compatible\"\n        title=\"Events on different HTML elements are not compatible\"\n        src=\"/static/27ddaa858d4e9c58bb4eaf90f29b0426/fcda8/event-incompatible.png\"\n        srcset=\"/static/27ddaa858d4e9c58bb4eaf90f29b0426/12f09/event-incompatible.png 148w,\n/static/27ddaa858d4e9c58bb4eaf90f29b0426/e4a3f/event-incompatible.png 295w,\n/static/27ddaa858d4e9c58bb4eaf90f29b0426/fcda8/event-incompatible.png 590w,\n/static/27ddaa858d4e9c58bb4eaf90f29b0426/efc66/event-incompatible.png 885w,\n/static/27ddaa858d4e9c58bb4eaf90f29b0426/c83ae/event-incompatible.png 1180w,\n/static/27ddaa858d4e9c58bb4eaf90f29b0426/08037/event-incompatible.png 1379w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>￼￼￼</p>\n<p>We got an error indicating near the end that <code>HTMLSelectElement</code> is not assignable to <code>HTMLInputElement</code>. Well, it is not, indeed, and our handler was defined to accept the former only and we’re unable to reuse that handler directly. A similar problem occurs if we want to attach the same handler to the events of multiple types (i.e. change, click, mouse interaction etc.) – <code>ChangeEvent&#x3C;T></code> and <code>MouseEvent&#x3C;T></code> are not compatible.</p>\n<p>Fortunately, TypeScript provides a decent set of type system features that might help us here. First, we can use the common ancestor event type instead of the specific <code>ChangeEvent</code> – <code>SyntheticEvent</code> is a good fit. The generic parameter that describes the type of element we handle our event on is more troublesome. We might try with a <code>HTMLElement</code> base type and in some cases it will suffice. But my usual case for the generic event handling is to handle multiple form elements and access its value attributes. Apparently there is no common type for all form elements that defines the <code>value</code> attribute. We have at least two ways to work around it. First, the mercy of <a href=\"http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types\">union types</a> where we can specify an alternative of types we want to handle and its common attributes will be freely available: </p>\n<pre><code class=\"language-typescript\">onGenericEvent: (event: React.SyntheticEvent&#x3C;HTMLSelectElement | HTMLInputElement>) => void\n</code></pre>\n<p>This is nice and explicit, although it doesn’t scale well if we want to handle more than few elements at once. The second solution uses the <a href=\"https://basarat.gitbooks.io/typescript/docs/types/type-compatibility.html#structural\">structural type compatibility</a> – yet another extremely neat TypeScript’s type system functionality that allows us to define and compare types by its structure only. If our case is to read a value of <code>value</code> attribute of the handled element’s only, we might state it explicitly in our handler type definition:</p>\n<pre><code class=\"language-typescript\">onGenericEvent: (event: React.SyntheticEvent&#x3C;{value: string}>) => void\n</code></pre>\n<p>The TypeScript’s type system allows us to choose which level of specificity vs. flexibility is appropriate in our case.</p>\n<h3>Ugly case of generic <code>setState</code></h3>\n<p>It’s not all flowers and roses, unfortunately. My typical scenario for form handling in React is to directly set the component’s state properties from the form elements values on their change events:</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={event => this.setState({firstName: event.currentTarget.value})} />\n</code></pre>\n<p>We might try to keep it generic by eliminating the duplication of the input’s name and assuming the name matches the key we want to set within the state and use <a href=\"http://www.benmvp.com/learning-es6-enhanced-object-literals/\">enhanced object literals</a> from ES6 specification (the thing with dynamic property names specified in square brackets):</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={event => this.setState({[event.currentTarget.name]: event.currentTarget.value})} />\n</code></pre>\n<p>As we have previously seen, TypeScript ensures the keys of the object we pass to <code>setState</code> match the actual properties of our component’s state. But here, TypeScript compiler (as of 2.6.1 at least) is not that smart to figure out what the actual value of event’s target <code>name</code> attribute would be, even though it can only be equal to <code>firstName</code> in this case. For TypeScript it is a general string and this is too wide to be considered valid for our <code>setState</code> call, unfortunately:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fdfa211253b20172dced05cf334d08f9/c6ff8/event-generic.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 7.4324324324324325%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAAAsTAAALEwEAmpwYAAAARUlEQVQI1yXFQQ6AIAwAQf8khbtBlEJb+f9j1kQPk9lKTogISRJJdnLJWCw8ggjD3Jn+MGfgsdBhqP66Dtrdqe36PurJC4nDJEE9vEy4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TypeScript is unable to specify down setState parameter types\"\n        title=\"TypeScript is unable to specify down setState parameter types\"\n        src=\"/static/fdfa211253b20172dced05cf334d08f9/fcda8/event-generic.png\"\n        srcset=\"/static/fdfa211253b20172dced05cf334d08f9/12f09/event-generic.png 148w,\n/static/fdfa211253b20172dced05cf334d08f9/e4a3f/event-generic.png 295w,\n/static/fdfa211253b20172dced05cf334d08f9/fcda8/event-generic.png 590w,\n/static/fdfa211253b20172dced05cf334d08f9/efc66/event-generic.png 885w,\n/static/fdfa211253b20172dced05cf334d08f9/c6ff8/event-generic.png 1088w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>￼￼￼</p>\n<p>We may work around it with type cast to inform TypeScript compiler what is the range of values we might potentially expect from <code>event.currentTarget.name</code> (assuming <code>State</code> describes the state of our component). The <code>keyof State</code> construct informs the compiler that the strings there may only be those that are defined by <code>State</code> interface structure:</p>\n<pre><code>&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={e => this.setState({[e.currentTarget.name as keyof State]: e.currentTarget.value})}/>\n</code></pre>\n<p>Or, alternatively, if we want to avoid type casts, we may satisfy the <code>setState</code> call by ensuring the full state is always passed (including the expected modifications). It is actually taking advantage of a bit separate React’s feature than the partial state update, but should behave the same way:</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={e => this.setState({...this.state, [e.currentTarget.name]: e.currentTarget.value})}/>\n</code></pre>\n<p>Note I’m using not-yet-standard <a href=\"https://github.com/tc39/proposal-object-rest-spread\">object spread operator</a> here. It creates a copy of <code>this.state</code> and replaces (or adds) a single property to this copy – in this case it will set <code>firstName</code> property to the value of input’s <code>value</code> attribute, reflecting what the user has typed into the box.</p>\n<h2>What’s more?</h2>\n<p>As you might have already noticed, all the HTML elements have its attributes mapped into <code>HTML*Element</code> types we can benefit from whenever we’re operating on the elements. Similarly, a good subset of the CSS properties are mapped into the <code>CSSProperties</code> interface that defines all the predefined values the particular CSS property might use. This might be useful to use if we use any form of the <a href=\"https://reactjs.org/docs/dom-elements.html#style\">inline styles</a> in our components. It would provide a proper code completion and in some cases ensure the validation of our CSS definitions:\n￼\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 11.486486486486488%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbUlEQVQI123NSxLCIBAA0VxMK36qNMDAzECE6P3P0ZbJ1kUv3qqnYpVsRikZN8O8Ubyi3vD1RUiZJQgpKc8YmW93TvOF89+uTGKV/v7ga6eNjXVsaG2H+0DUiLmQ1BB1liQsv8meELMS5PAjRL7NY0vLL9uePgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TypeScript helps with CSS validity\"\n        title=\"TypeScript helps with CSS validity\"\n        src=\"/static/f3d259984dec726ce079057feae7c1e1/fcda8/css-properties.png\"\n        srcset=\"/static/f3d259984dec726ce079057feae7c1e1/12f09/css-properties.png 148w,\n/static/f3d259984dec726ce079057feae7c1e1/e4a3f/css-properties.png 295w,\n/static/f3d259984dec726ce079057feae7c1e1/fcda8/css-properties.png 590w,\n/static/f3d259984dec726ce079057feae7c1e1/ae694/css-properties.png 850w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>￼￼￼</p>\n<p>I hope you already feel that TypeScript can offer a lot of benefits to your React codebase, even though we’ve just touched the iceberg tip. In the <a href=\"https://brightinventions.pl/blog/using-typescript-with-redux/\">next post</a> we'll add Redux into the mix and see how TypeScript can help us there, too.</p>","excerpt":"In the recent post we discussed how we can start a new React project with TypeScript to benefit from all the goodies of type checks and…","frontmatter":{"slug":null,"title":"5 (or more) ways to benefit from TypeScript in React projects","description":null,"author":"adam","tags":["React","TypeScript","web"],"date":"2018-04-11T22:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#282828","images":{"fallback":{"src":"/static/2aa6775781ed8b57ab970c8590174140/fa99d/props-immutable.png","srcSet":"/static/2aa6775781ed8b57ab970c8590174140/de282/props-immutable.png 136w,\n/static/2aa6775781ed8b57ab970c8590174140/528c1/props-immutable.png 272w,\n/static/2aa6775781ed8b57ab970c8590174140/fa99d/props-immutable.png 544w","sizes":"(min-width: 544px) 544px, 100vw"},"sources":[{"srcSet":"/static/2aa6775781ed8b57ab970c8590174140/49d96/props-immutable.webp 136w,\n/static/2aa6775781ed8b57ab970c8590174140/71acd/props-immutable.webp 272w,\n/static/2aa6775781ed8b57ab970c8590174140/ca98c/props-immutable.webp 544w","type":"image/webp","sizes":"(min-width: 544px) 544px, 100vw"}]},"width":544,"height":95}}}},"timeToRead":10,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-04-12-5-ways-to-benefit-from-typescript-in-react.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-04-12-5-ways-to-benefit-from-typescript-in-react.md"}},"staticQueryHashes":["2189233960","3181594896"]}