{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/how-to-convert-an-express-app-to-aws-lambda","result":{"data":{"markdownRemark":{"html":"<p>In this post we will see how to convert an existing <a href=\"https://expressjs.com/\">express</a>  application to AWS Lambda. This can help reduce AWS bill even by an order of magnitude. We will also use <a href=\"https://github.com/bright/cloudform\">cloudform</a> to describe the <a href=\"https://aws.amazon.com/cloudformation/\">CloudFormation</a> stack.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 465px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/46bc2ff2509d5263f6fb5067702578ae/51ce3/express-js.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.405405405405407%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRj4AAABXRUJQVlA4IDIAAAAQAwCdASoUAAYAPtFUo0uoJKMhsAgBABoJaQAAex/+iAAA/vILCdwCVLhodOVQAAAAAA=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"express.js\"\n        title=\"express.js\"\n        src=\"/static/46bc2ff2509d5263f6fb5067702578ae/51ce3/express-js.webp\"\n        srcset=\"/static/46bc2ff2509d5263f6fb5067702578ae/cbe2e/express-js.webp 148w,\n/static/46bc2ff2509d5263f6fb5067702578ae/3084c/express-js.webp 295w,\n/static/46bc2ff2509d5263f6fb5067702578ae/51ce3/express-js.webp 465w\"\n        sizes=\"(max-width: 465px) 100vw, 465px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>An express app</h2>\n<p>For our example to be complete we need an express application. Let's use a single <code>index.js</code> file to define it:</p>\n<pre><code class=\"language-javascript\">const express = require('express');\n\nfunction apiRoutes(){\n    const routes = new express.Router();\n\n    routes.get('/v1/version', (req, res) => res.send({version: '1'}));\n\n    routes.post('/v1/echo', (req, res) => res.send({...req.body}));\n\n    return routes;\n}\n\n\nconst app = express()\n    .use(express.json())\n    .use(apiRoutes());\n\napp.listen(3000, () => console.log(`Listening on 3000`));\n</code></pre>\n<p>The above application has only 2 endpoints: </p>\n<ul>\n<li><code>GET /v1/version</code> returns API version</li>\n<li><code>POST /v1/echo</code> sends back the request body</li>\n</ul>\n<p>We start the application as any other node app with <code>node index.js</code>.</p>\n<h2>Convert the express app to AWS Lambda</h2>\n<p><a href=\"https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html\">The AWS Lambda Node.js</a> runtime model differs from a simple <code>node fileName.js</code> invocation. For the AWS Lambda to invoke our application code we need to structure it appropriately. Thankfully the <a href=\"https://github.com/awslabs/aws-serverless-express\">aws-serverless-express</a> module adapts express to AWS Lambda Node.js runtime model.</p>\n<p>Let's adapt our <code>index.js</code> file to support <code>aws-serverless-express</code>:</p>\n<pre><code class=\"language-javascript\">const isInLambda = !!process.env.LAMBDA_TASK_ROOT;\nif (isInLambda) {\n    const serverlessExpress = require('aws-serverless-express');\n    const server = serverlessExpress.createServer(app);\n    exports.main = (event, context) => serverlessExpress.proxy(server, event, context)\n} else {\n    app.listen(3000, () => console.log(`Listening on 3000`));\n}\n</code></pre>\n<p>The <code>main</code> function is called by the AWS Lambda Node.js runtime. Note that we've used <a href=\"https://docs.aws.amazon.com/lambda/latest/dg/current-supported-versions.html#lambda-environment-variables\"><code>LAMBDA_TASK_ROOT</code></a> environment variable to detect if the app is running inside AWS Lambda. It is better to split the express application setup and <code>listen</code> call into separate files and use 2 different <em>main</em> files e.g. <code>development.js</code> calling <code>listen(port)</code> and <code>lambda.js</code> using <code>aws-serverless-express</code>. However, this would complicate our example unnecessarily.</p>\n<h2>Deploy the express app to AWS Lambda</h2>\n<p>I already showed <a href=\"%7B%25%20post_url%202018-03-12-deploy-lambda-with-cloudformation%20%25%7D\">how we can deploy lambda with cloudform</a>. We will use the previous example as a base:</p>\n<pre><code class=\"language-typescript\">import cloudform, { Lambda, IAM, Fn, ApiGateway, Refs,  } from 'cloudform';\nimport { FunctionProperties } from 'cloudform/types/lambda/function';\nimport { readFileSync } from 'fs';\n\nconst\n    LambdaExecutionRole = 'LambdaExecutionRole',\n    ExpressMain = 'ExpressMain',\n    RestApi = 'RestApi',\n    RestApiMainResource = 'RestApiMainResource',\n    PackageKey = 'PackageKey',\n    RestApiDeployment = 'RestApiDeployment';\n\nexport default cloudform({\n    Parameters: {\n        PackageKey: {\n            Type: 'String',\n            Default: 'express-lambda.zip'\n        }\n    },\n    Resources: {\n        [ExpressMain]: new Lambda.Function({\n            Code: { S3Bucket: 'bright-tmp', S3Key: Fn.Ref(PackageKey) },\n            Handler: \"index.main\",\n            Role: Fn.GetAtt(LambdaExecutionRole, \"Arn\"),\n            Runtime: \"nodejs6.10\"\n        }),\n        [LambdaExecutionRole]: new IAM.Role({\n            AssumeRolePolicyDocument: {\n                Statement: [{\n                    Effect: \"Allow\",\n                    Principal: { Service: [\"lambda.amazonaws.com\"] },\n                    Action: [\"sts:AssumeRole\"]\n                }]\n            },\n            ManagedPolicyArns: [\"arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\"]\n        }),\n        PermissionToInvokeLambda: new Lambda.Permission({\n            Action: 'lambda:InvokeFunction',\n            FunctionName: Fn.GetAtt(ExpressMain, 'Arn'),\n            Principal: 'apigateway.amazonaws.com',\n            SourceArn: Fn.Join('', [\n                'arn:aws:execute-api:', Refs.Region, ':', Refs.AccountId, ':', Fn.Ref(RestApi), '/*']\n            )\n        })\n        ... // Rest Api Gateway see below\n    }\n})\n</code></pre>\n<p>For the AWS Lambda function source we use a zip file hosted in a S3 Bucket named <code>packages</code> at key specified in the template parameter <code>PackageKey</code>. The package zip file must contain all application source code including <code>node_modules</code>. We also define <code>PermissionToInvokeLambda</code> so that API Gateway can invoke the lambda function.</p>\n<h2>Add API Gateway to call AWS Lambda</h2>\n<p>To be able to invoke the AWS Lambda function using HTTP protocol we will use <a href=\"https://aws.amazon.com/api-gateway/\">API Gateway</a>. There are multiple ways of setting up the API gateway but we will use an appoach that is simplest in my opinion.</p>\n<pre><code class=\"language-typescript\">[RestApi]: new ApiGateway.RestApi({ Name: \"Express API\" }),\n[RestApiMainResource]: new ApiGateway.Resource({\n    RestApiId: Fn.Ref(RestApi),\n    ParentId: Fn.GetAtt(RestApi, 'RootResourceId'),\n    PathPart: \"{proxy+}\",\n}),\nRestApiMethod: new ApiGateway.Method({\n    HttpMethod: 'ANY',\n    ResourceId: Fn.Ref(RestApiMainResource),\n    RestApiId: Fn.Ref(RestApi),\n    AuthorizationType: 'NONE',\n    Integration: {\n        Type: \"AWS_PROXY\",\n        IntegrationHttpMethod: \"POST\",\n        Uri: Fn.Sub(\"arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ExpressMain.Arn}/invocations\", {})\n    }\n}),\n[RestApiDeployment]: new ApiGateway.Deployment({\n    RestApiId: Fn.Ref(RestApi),\n    StageName: 'test'\n})\n</code></pre>\n<p>We first define a <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html\"><code>RestApi</code></a> which is a collection of resources with various configuration options describing the API. Next is the <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-resource.html\"><code>RestApiMainResource</code></a> which depicts a single REST resource. However, in our case we use wildcard <code>PathPart</code> to match <strong>all</strong> paths. This way we can have a single resource encompassing all API endpoints. For the <code>RestApiMainResource</code> we also need to define a single <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-method.html\"><code>RestApiMethod</code></a>. Note that the <code>HttpMethod</code> is set to <code>ANY</code> which matches all verbs. The <code>Integration</code> specifies that we would like to proxy requests to the <code>ExpressMain</code> AWS Lambda function. Last but not least we define a <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-deployment.html\"><code>RestApiDeployment</code></a> so that we have an URL to call the API.</p>\n<p>It is handy to define <code>Outputs</code> in our template so that we can easily access the API url:</p>\n<pre><code class=\"language-typescript\">Outputs: {\n    RestApiUrl: {\n        Value: Fn.Join('', [Fn.Ref(RestApi), '.execute-api.', Refs.Region, '.amazonaws.com/test'])\n    }\n}\n</code></pre>\n<h2>Test API Gateway calling AWS Lambda</h2>\n<p>With our cloudform template deployed with a single command:</p>\n<pre><code class=\"language-bash\">aws cloudformation update-stack \\\n  --stack-name lambda-example \\\n  --capabilities CAPABILITY_IAM \\\n  --template-body file://&#x3C;(./node_modules/.bin/cloudform aws-template.ts)\n</code></pre>\n<p>We can also fetch the API url:</p>\n<pre><code class=\"language-bash\">API_URL=$(aws cloudformation describe-stacks \\\n  --stack-name lambda-example \\\n  --query 'Stacks[0].Outputs[?OutputKey==`RestApiUrl`].OutputValue' \\\n  --output text)\n</code></pre>\n<p>Finally, with the help of <a href=\"https://httpie.org/\"><code>httpie</code></a> we can test our API:</p>\n<pre><code class=\"language-bash\">> http https://${API_URL}/v1/version\n\nHTTP/1.1 200 OK\nConnection: keep-alive\nContent-Length: 15\nContent-Type: application/json; charset=utf-8\nDate: Mon, 28 May 2018 19:58:13 GMT\nVia: 1.1 XXXXXXXXXXXXX.cloudfront.net (CloudFront)\nX-Amz-Cf-Id: XXXXXXXXXXXXX==\nX-Amzn-Trace-Id: Root=1-5b0c5f54-806e190d437c7d31a4a0d4ba\nX-Cache: Miss from cloudfront\netag: W/\"f-sHigu4BMVa0IJ0LR3NDJ5y8l4sc\"\nx-amz-apigw-id: HnPVQH4yjoEF8-w=\nx-amzn-Remapped-connection: close\nx-amzn-Remapped-content-length: 15\nx-amzn-Remapped-date: Mon, 28 May 2018 19:58:13 GMT\nx-amzn-RequestId: 73eff8a6-62b1-11e8-907c-79117668835e\nx-powered-by: Express\n\n{\n    \"version\": \"1\"\n}\n</code></pre>\n<p>And a <code>POST</code> to the echo endpoint:</p>\n<pre><code class=\"language-bash\">http https://${API_URL}/v1/echo message=\"Hello 👋 My name is Piotr\"\n\nHTTP/1.1 200 OK\nConnection: keep-alive\nContent-Length: 41\nContent-Type: application/json; charset=utf-8\nDate: Mon, 28 May 2018 20:00:31 GMT\nVia: 1.1 XXXXXXXXXXXXX.cloudfront.net (CloudFront)\nX-Amz-Cf-Id: XXXXXXXXXXXXX==\nX-Amzn-Trace-Id: Root=1-5b0c5fdf-802178cceb5160684ef2cc34\nX-Cache: Miss from cloudfront\netag: W/\"29-SKqhJThIfjmVId6IIeTilD7Mkk0\"\nx-amz-apigw-id: HnPq5HeJjoEFuRQ=\nx-amzn-Remapped-connection: close\nx-amzn-Remapped-content-length: 41\nx-amzn-Remapped-date: Mon, 28 May 2018 20:00:31 GMT\nx-amzn-RequestId: c67b41c0-62b1-11e8-a23f-c7cbebde15f2\nx-powered-by: Express\n\n{\n    \"message\": \"Hello 👋 My name is Piotr\"\n}\n</code></pre>\n<h2>Reduced infrastructure cost</h2>\n<p>With the above setup we no longer have to pay for an always running EC2 instance. Our monthly bill depends on the number of requests that are executed against the exposed API. More than that, we get much better scalability characteristics, especially when we have nonlinear request rates. </p>","excerpt":"In this post we will see how to convert an existing express  application to AWS Lambda. This can help reduce AWS bill even by an order of…","frontmatter":{"slug":null,"title":"How to convert an express app to AWS Lambda?","description":null,"author":"piotr","tags":["aws","cloudformation","lambda","cloudform"],"date":"2018-05-29T22:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/46bc2ff2509d5263f6fb5067702578ae/c0697/express-js.webp","srcSet":"/static/46bc2ff2509d5263f6fb5067702578ae/9a331/express-js.webp 116w,\n/static/46bc2ff2509d5263f6fb5067702578ae/659e4/express-js.webp 233w,\n/static/46bc2ff2509d5263f6fb5067702578ae/c0697/express-js.webp 465w","sizes":"(min-width: 465px) 465px, 100vw"},"sources":[]},"width":465,"height":141}}}},"timeToRead":7,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-05-30-how-to-convert-an-express-app-to-aws-lambda.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-05-30-how-to-convert-an-express-app-to-aws-lambda.md"}},"staticQueryHashes":["2189233960","3181594896"]}