{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/testing-android-viewmodels","result":{"data":{"markdownRemark":{"html":"<p>In my <a href=\"https://brightinventions.pl/blog/injectable-android-viewmodels/\">previous post</a> I described how to implement injectable Android view models using Dagger and <a href=\"https://developer.android.com/topic/libraries/architecture/viewmodel.html\">ViewModel</a> library from <a href=\"https://developer.android.com/topic/libraries/architecture/.html\">Android Architecture Components</a>. In this post I will show a simple way to unit test the view model created then. You can find the full code in the same repository as previously <a href=\"https://github.com/azabost/simple-mvvm-example/tree/7b051fd7a16853e3d9655767a887d9a830133d2d\">on GitHub</a>.</p>\n<h1>The structure</h1>\n<p><img src=\"../../../static/images/testing-android-viewmodels/structure.svg\" alt=\"Structure\">{: .center-image}</p>\n<p>The <code>MainViewModel</code> view model exposes three <a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> <code>Observable</code>s which Activity (<code>MainActivity</code>) subscribes to in order to receive notifications, e.g. to display an error message. There is also the <code>getRepo</code> function that triggers fetching some data from the GitHub API and the <code>data</code> variable that stores the fetched data.</p>\n<p>The mentioned members are divided into three interfaces implemented by the view model but it's mainly for the clarity of the example (you can easily tell which members are used by the Activity and the Fragments).</p>\n<p>The only view model's dependency (provided by Dagger) is <code>GitHubClient</code> which has a method for fetching some data.</p>\n<p>It's also worth noting that the Activity and the Fragments use the same instance of <code>MainViewModel</code>. That's why it can both fetch the data when <code>LoadingFragment</code> requests it, tell <code>MainActivity</code> to show an error if anything goes wrong and work as a data store for <code>DataFragment</code>. In order to achieve this type of sharing the view model instance between the Activity and the Fragments, they must request the view model by passing the Activity reference while getting it:</p>\n<p><code>ViewModelProviders.of(activity, vmFactory).get(...)</code></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e0af646899dca9fd1a9ed46958ee29a8/0f98f/stethoscope.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.51351351351351%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAQL/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAGqxWDzkP/EABkQAAMBAQEAAAAAAAAAAAAAAAABAhEEIf/aAAgBAQABBQLmTmNWki9Z/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAwEBAAAAAAAAAAAAAAAAEBFRAAH/2gAIAQEABj8CnMioP//EABsQAAICAwEAAAAAAAAAAAAAAAABEVEQIWFx/9oACAEBAAE/IYy1SLtYXQ6mqnpJ/9oADAMBAAIAAwAAABC7H//EABURAQEAAAAAAAAAAAAAAAAAABAx/9oACAEDAQE/EIf/xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQIBAT8QFX//xAAeEAEAAgEEAwAAAAAAAAAAAAABABExIUFR8HGBkf/aAAgBAQABPxBoVGy5veIdiur3uI5lRVt548RSECp+PXMaaG0//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Stethoscope\"\n        title=\"Stethoscope\"\n        src=\"/static/e0af646899dca9fd1a9ed46958ee29a8/1c72d/stethoscope.jpg\"\n        srcset=\"/static/e0af646899dca9fd1a9ed46958ee29a8/a80bd/stethoscope.jpg 148w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/1c91a/stethoscope.jpg 295w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/1c72d/stethoscope.jpg 590w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/a8a14/stethoscope.jpg 885w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/fbd2c/stethoscope.jpg 1180w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/0f98f/stethoscope.jpg 1920w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<h1>Testing</h1>\n<h2>Prepare dependencies</h2>\n<p>Normally <code>MainViewModel</code> uses a <code>GitHubClient</code> implementation that calls the GitHub API using <a href=\"https://github.com/square/retrofit\">Retrofit</a> HTTP client. In tests you would probably prefer to either mock the server (e.g. with <a href=\"https://github.com/square/okhttp/tree/master/mockwebserver\">MockWebServer</a>) or just the <code>GitHubClient</code> implementation so that it won't make the calls at all. In this example I'm going to use the latter approach (but testing the calls to a mocked server is also a good idea and you can do it separately).</p>\n<h3>Mock API client</h3>\n<p>The mocked implementation of the <code>GitHubClient</code> is very simple. Its constructor accepts a response it should return, an optional error it should throw instead of the response and a scheduler so that we can control the exact moment the data/error is returned. The error and the response are mutable properties so we can adjust them just before calling <code>getRepo</code> method.</p>\n<pre><code class=\"language-kotlin\">import com.azabost.simplemvvm.net.response.RepoResponse\nimport io.reactivex.Observable\nimport io.reactivex.Scheduler\n\nclass MockGitHubClient(\n        val scheduler: Scheduler,\n        var repoResponse: RepoResponse = RepoResponse(1),\n        var error: Throwable? = null\n) : GitHubClient {\n\n    override fun getRepo(owner: String, repo: String): Observable&#x3C;RepoResponse> {\n        val response = error?.let { return Observable.error(it) } ?: Observable.just(repoResponse)\n        return response.subscribeOn(scheduler).observeOn(scheduler)\n    }\n}\n</code></pre>\n<p><em>Note: it can also be implemented using Mockito - you can find the updated version on GitHub.</em></p>\n<h3>Setting things up</h3>\n<p>I put all the <code>MainViewModel</code> tests in the <code>MainViewModelTests</code> class. It has a few properties:</p>\n<ul>\n<li><code>MainViewModel</code></li>\n<li><code>TestObserver</code>s for every <code>Observable</code> exposed by <code>MainViewModel</code></li>\n<li><code>MockGitHubClient</code></li>\n<li><code>TestScheduler</code> that is passed to <code>MockGitHubClient</code></li>\n</ul>\n<p>They are initialized in the <code>setup</code> method.</p>\n<p><code>TestObserver</code>s record events passed by <code>Observable</code>s and they allow to make assertions about them e.g. if a value has been emitted and what it was exactly.</p>\n<p><code>TestScheduler</code> controls the time when <code>MockGitHubClient</code> emits responses so that we can defer it and test what happens before the subscription completes (e.g. the progress animation should be still visible).</p>\n<pre><code class=\"language-kotlin\">class MainViewModelTests {\n    lateinit var vm: MainViewModel\n    lateinit var gitHubClient: MockGitHubClient\n    lateinit var testScheduler: TestScheduler\n    lateinit var progressObserver: TestObserver&#x3C;Boolean>\n    lateinit var errorObserver: TestObserver&#x3C;Int>\n    lateinit var showDataObserver: TestObserver&#x3C;Unit>\n\n    @Before\n    fun setup() {\n        testScheduler = TestScheduler()\n        gitHubClient = MockGitHubClient(testScheduler)\n        vm = MainViewModel(gitHubClient)\n        setupObservers(vm)\n    }\n\n    fun setupObservers(vm: MainViewModel) {\n        progressObserver = TestObserver.create()\n        vm.progress.subscribe(progressObserver)\n        errorObserver = TestObserver.create()\n        vm.errors.subscribe(errorObserver)\n        showDataObserver = TestObserver.create()\n        vm.showData.subscribe(showDataObserver)\n    }\n</code></pre>\n<h2>Writing some tests</h2>\n<p>Below you can find three simple examples.</p>\n<h3>Example 1</h3>\n<p>Test if positive response from the API triggers <code>showData</code> <code>Observable</code> and stores the data for later usage in the <code>data</code> variable.</p>\n<pre><code class=\"language-kotlin\">@Test\nfun getRepoShouldShowData() {\n    val data = RepoResponse(12345)\n    gitHubClient.repoResponse = data\n\n    vm.getRepo(\"any\", \"thing\")\n    testScheduler.triggerActions()\n\n    showDataObserver.assertValueCount(1)\n    vm.data.shouldEqual(data)\n}\n</code></pre>\n<p><em>Note: the <code>shouldEqual</code> method comes from <a href=\"https://github.com/miensol/shouldko\">ShouldKO</a> which I really recommend but you can use any assertions you like.</em></p>\n<h3>Example 2</h3>\n<p>Test if HTTP exception triggers <code>error</code> <code>Observable</code> with the HTTP-specific error message.</p>\n<pre><code class=\"language-kotlin\">@Test\nfun getRepoErrorShouldShowHttpError() {\n    gitHubClient.error = HttpErrors.getHttpException(404)\n\n    vm.getRepo(\"any\", \"thing\")\n    errorObserver.assertValue(HttpErrors.DEFAULT_HTTP_ERROR_MESSAGE)\n}\n</code></pre>\n<h3>Example 3</h3>\n<p>Test if calling <code>getRepo</code> triggers <code>progress</code> <code>Observable</code> twice so that it should tell the view to show the loader and then to hide it.</p>\n<pre><code class=\"language-kotlin\">@Test\nfun getRepoShouldShowProgress() {\n    vm.getRepo(\"any\", \"thing\")\n    progressObserver.assertValue(true)\n\n    testScheduler.triggerActions()\n    progressObserver.assertValueSequence(listOf(true, false))\n}\n</code></pre>\n<h1>Conclusion</h1>\n<p>As you can see, using <code>ViewModel</code>s and RxJava <code>Observable</code>s gives a very simple way to write unit tests for your code. I believe this great possibility will also encourage you to extract the business logic from the Android application components like Activities so that it can be tested without using instrumented tests or mocking the platform (e.g. with Robolectric).</p>","excerpt":"In my previous post I described how to implement injectable Android view models using Dagger and ViewModel library from Android Architecture…","frontmatter":{"slug":null,"title":"Testing Android ViewModels","description":null,"author":"azabost","tags":["android","kotlin","viewmodel","mvvm","unit tests"],"date":"2018-01-02T23:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#d8d8d8","images":{"fallback":{"src":"/static/e0af646899dca9fd1a9ed46958ee29a8/69fae/stethoscope.jpg","srcSet":"/static/e0af646899dca9fd1a9ed46958ee29a8/8aa46/stethoscope.jpg 480w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/38951/stethoscope.jpg 960w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/69fae/stethoscope.jpg 1920w","sizes":"(min-width: 1920px) 1920px, 100vw"},"sources":[{"srcSet":"/static/e0af646899dca9fd1a9ed46958ee29a8/1c025/stethoscope.webp 480w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/1c8d4/stethoscope.webp 960w,\n/static/e0af646899dca9fd1a9ed46958ee29a8/d2e5e/stethoscope.webp 1920w","type":"image/webp","sizes":"(min-width: 1920px) 1920px, 100vw"}]},"width":1920,"height":1225}}}},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-03-testing-android-viewmodels.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-03-testing-android-viewmodels.md"}},"staticQueryHashes":["2189233960","3181594896"]}