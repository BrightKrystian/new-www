{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/aws-cloudformation-patterns-practices-cloudform","result":{"data":{"markdownRemark":{"html":"<p>Recently we introduced <a href=\"https://brightinventions.pl/blog/introducing-cloudform-tame-aws-cloudformation-templates/\"><code>cloudform</code></a> – our <a href=\"https://www.npmjs.com/package/cloudform\">open-source library</a> that allows for managing <a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a> template files through TypeScript. Its core value proposition is to cope with the massive JSON files in a sane and familiar way – to treat it as any other TypeScript code we have in our project. But what does it actually mean? Let's look at some examples to check where this path can lead us to.</p>\n<p>Just as a recap, the basic <code>cloudform</code> usage allows us to replace the lengthy and verbose JSON definition of AWS CloudFormation resource, like this:</p>\n<pre><code class=\"language-json\">{\n  \"VPC\": {\n    \"Type\": \"AWS::EC2::VPC\",\n    \"Properties\": {\n      \"CidrBlock\": {\n        \"Fn::FindInMap\": [\n          \"NetworkingConfig\",\n          \"VPC\",\n          \"CIDR\"\n        ]\n      },\n      \"EnableDnsHostnames\": true,\n      \"Tags\": [\n        {\n          \"Key\": \"Application\",\n          \"Value\": {\n            \"Ref\": \"AWS::StackName\"\n          }\n        },\n        {\n          \"Key\": \"Network\",\n          \"Value\": \"Public\"\n        },\n        {\n          \"Key\": \"Name\",\n          \"Value\": {\n            \"Fn::Join\": [\n              \"-\",\n              [\n                {\n                  \"Ref\": \"AWS::StackId\"\n                },\n                \"VPC\"\n              ]\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<p>into totally equivalent piece of TypeScript:</p>\n<pre><code class=\"language-typescript\">{\n  VPC: new EC2.VPC({\n      CidrBlock: Fn.FindInMap('NetworkingConfig', 'VPC', 'CIDR'),\n      EnableDnsHostnames: true,\n      Tags: [\n          new ResourceTag('Application', Refs.StackName),\n          new ResourceTag('Network', 'Public'),\n          new ResourceTag('Name', Fn.Join('-', [Refs.StackId, 'VPC']))\n      ]\n  })\n}\n</code></pre>\n<p>Let's try something more.</p>\n<h2>Get rid of repetitive values</h2>\n<p>Some references or other variables in our template repeat many times. With <code>cloudform</code> it's a bit more concise than in pure JSON – compare <code>Refs.StackName</code> to <code>{\"Ref\": \"AWS::StackName\"}</code>. We also often reference more complex constructs like concatenations – in pure JSON it quickly grows complex:</p>\n<pre><code class=\"language-json\">{\n  \"Fn::Join\": [\n    \"-\",\n    [\n      \"app-name-\",\n      {\n        \"Ref\": \"DeployEnv\"\n      }\n    ]\n  ]\n}\n</code></pre>\n<p>With <code>cloudform</code> the same is expressed as </p>\n<pre><code class=\"language-typescript\">Fn.Join('-', ['app-name-', Fn.Ref('DeployEnv')])\n</code></pre>\n<p>But if we reference this kind of value several times, we can just save it as a TypeScript-level constant and just reference it in TypeScript:</p>\n<pre><code class=\"language-typescript\">const envAppName = Fn.Join('-', ['app-name-', Fn.Ref('DeployEnv')])\n\nexport default cloudform({\n    // ...\n    ParameterValueSomewhereInResources: envAppName\n})\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7b639d81ae7c879291b2b643e0cf98a4/eea4a/mindmap.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHlPLSggf/EABcQAQADAAAAAAAAAAAAAAAAAAARIDH/2gAIAQEAAQUCYmn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAAASBh/9oACAEBAAY/AhbP/8QAGBABAQEBAQAAAAAAAAAAAAAAEQABITH/2gAIAQEAAT8hg7fDKeWbF//aAAwDAQACAAMAAAAQC+//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMVFxgZH/2gAIAQEAAT8Qa0pXyJpboOAzLOPWCw8iUFtcRF9Yn//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Structure and order for our AWS CloudFormation templates\"\n        title=\"Structure and order for our AWS CloudFormation templates\"\n        src=\"/static/7b639d81ae7c879291b2b643e0cf98a4/1c72d/mindmap.jpg\"\n        srcset=\"/static/7b639d81ae7c879291b2b643e0cf98a4/a80bd/mindmap.jpg 148w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/1c91a/mindmap.jpg 295w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/1c72d/mindmap.jpg 590w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/a8a14/mindmap.jpg 885w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/fbd2c/mindmap.jpg 1180w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/eea4a/mindmap.jpg 1280w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Get rid of repetitive resources</h2>\n<p>The same concept applies well for similar resources definitions. Let's say we need ten SQS queues defined in our infrastructure. In pure JSON it means we have to repeat the same queue definition piece over and over again, changing probably just a name parameter.</p>\n<pre><code class=\"language-json\">{\n  \"NthQueue\": {\n    \"Type\": \"AWS::SQS::Queue\",\n    \"Properties\": {\n      \"QueueName\": {\n        \"Fn::Join\": [\n          \"-\",\n          [\n            {\n              \"Ref\": \"DeployEnv\"\n            },\n            \"nth-queue\"\n          ]\n        ]\n      },\n      \"RedrivePolicy\": {\n        \"maxReceiveCount\": 4,\n        \"deadLetterTargetArn\": {\n          \"Fn::GetAtt\": [\n            \"DefaultDeadLetterQueue\",\n            \"Arn\"\n          ]\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Going further with our previous concept of removing repetitions, we can apply pretty standard refactoring – extract a method. So we can define the piece of TypeScript that generates the Queue resource object and just invoke it within our template for each queue to be defined:</p>\n<pre><code class=\"language-typescript\">const defineQueue = (name: string) => {\n    return new SQS.Queue({\n        QueueName: Fn.Join('-', [Fn.Ref('DeployEnv'), name, 'queue']),\n        RedrivePolicy: {\n            maxReceiveCount: 4,\n            deadLetterTargetArn: Fn.GetAtt('DefaultDeadLetterQueue', 'Arn')\n        }\n    })\n}\n\nexport default cloudform({\n    Resources: {\n        Queue1: defineQueue(\"first\"),\n        Queue2: defineQueue(\"second\"),\n        // ...\n        QueueN: defineQueue(\"nth\")\n    }\n})\n</code></pre>\n<h2>Get rid of static FindInMap</h2>\n<p>It often makes sense to have some common configuration values grouped together and possibly different depending on some parameter, for example a deployment environment like staging vs. production. In a pure JSON template we can use <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-findinmap.html\"><code>Fn::FindInMap</code></a> to reach the desired value where it is needed. We need to pass all the keys as a path to our value, possibly using parameter references (<code>Ref</code>) or other variables. But if our path is static, with <code>cloudform</code> we might get rid of verbose map accessing and replace it with a native TypeScript object instead.</p>\n<p>So instead of:</p>\n<pre><code class=\"language-json\">{\n  \"Mappings\": {\n    \"NetworkingConfig\": {\n      \"VPC\": {\n        \"CIDR\": \"0.0.0.0/16\"\n      }\n    }\n  },\n  \"Resources\": {\n    \"VPC\": {\n      \"Type\": \"AWS::EC2::VPC\",\n      \"Properties\": {\n        \"CidrBlock\": {\n          \"Fn::FindInMap\": [\n            \"NetworkingConfig\",\n            \"VPC\",\n            \"CIDR\"\n          ]\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>we might create this mapping in TypeScript directly:</p>\n<pre><code class=\"language-typescript\">const NetworkingConfig = {\n    VPC: {\n        CIDR: \"0.0.0.0/16\"\n    }\n}\n\nexport default cloudform({\n    Resources: new EC2.VPC({\n        CidrBlock: NetworkingConfig.VPC.CIDR\n    })\n})\n</code></pre>\n<h2>Split into multiple files</h2>\n<p>Nobody likes large source files. And complex environment definitions tend to grow large. In pure JSON, we are not able to split the file easily. There is an option to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/create-reusable-transform-function-snippets-and-add-to-your-template-with-aws-include-transform.html\">import external snippets</a>, but it requires the snippet to be located on S3. Kind of cumbersome if we want to properly keep our infrastructure in source control and be serious in our <a href=\"https://www.infoq.com/code-infrastructure\">infrastructure-as-code approach</a>.</p>\n<p>With <code>cloudform</code> we are in the TypeScript world and nothing should stop us from treating parts of our template as TypeScript modules that can be imported into the final template. It might make sense to separate our networking stack module from the instances module and from the database module etc. – where each module might keep all the resources logically bound together – database access-related security groups might be defined together with the database, but ECS-related security groups might be defined together with the containers.</p>\n<p>Let's look at the database module example, <code>database.ts</code>:</p>\n<pre><code class=\"language-typescript\">export default {\n  DatabaseInstanceParameters: new RDS.DBParameterGroup({\n    Family: \"postgres9.6\"\n  }),\n  DatabaseInstance: new RDS.DBInstance({\n    DBName: Fn.Join('-', ['db', Fn.Ref('DeployEnv')]),\n    DBParameterGroupName: Fn.Ref('DatabaseInstanceParameters'),\n    VPCSecurityGroups: [\n        Fn.GetAtt('DatabaseSecurityGroup', 'GroupId')\n    ]\n    // ...\n  }),\n  DatabaseSecurityGroup: new EC2.SecurityGroup({\n    // ...\n  })\n}\n</code></pre>\n<p>And its usage within the actual template:</p>\n<pre><code class=\"language-typescript\">import databaseResources from './database'\n\nexport default cloudform({\n  Resources: Object.assign({}, databaseResources, /* and possibly more */)\n})\n</code></pre>\n<h2>Forget the actual JSON at all</h2>\n<p>With all the <code>cloudform</code> goodies around, we might forget the existence of the JSON file within our sources. It might make sense to generate it on the fly as a part of our build or deployment process. How about adding the template generation task to our NPM scripts:</p>\n<pre><code class=\"language-json\">{\n  \"generate-aws-template\": \"cloudform cloudformation/.ts > .build/template.out\",\n  \"deploy\": \"npm run generate-aws-template &#x26;&#x26; &#x3C;proceed with deployment using .build/template.out>\"\n}\n</code></pre>\n<p>There are probably a lot of other creative ways to use <code>cloudform</code> to simplify and manage our AWS CloudFormation templates. Feel free to share your ideas!</p>","excerpt":"Recently we introduced cloudform – our open-source library that allows for managing AWS CloudFormation template files through TypeScript…","frontmatter":{"slug":null,"title":"AWS CloudFormation patterns & practices with cloudform","description":null,"author":"adam","tags":["AWS","CloudFormation","open-source"],"date":"2017-12-14T23:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#282828","images":{"fallback":{"src":"/static/7b639d81ae7c879291b2b643e0cf98a4/d644e/mindmap.jpg","srcSet":"/static/7b639d81ae7c879291b2b643e0cf98a4/e2a8b/mindmap.jpg 320w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/d6005/mindmap.jpg 640w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/d644e/mindmap.jpg 1280w","sizes":"(min-width: 1280px) 1280px, 100vw"},"sources":[{"srcSet":"/static/7b639d81ae7c879291b2b643e0cf98a4/01f73/mindmap.webp 320w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/a2735/mindmap.webp 640w,\n/static/7b639d81ae7c879291b2b643e0cf98a4/45503/mindmap.webp 1280w","type":"image/webp","sizes":"(min-width: 1280px) 1280px, 100vw"}]},"width":1280,"height":778}}}},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-15-aws-cloudformation-patterns-practices-cloudform.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-15-aws-cloudformation-patterns-practices-cloudform.md"}},"staticQueryHashes":["2189233960","3181594896"]}