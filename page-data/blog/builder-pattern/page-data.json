{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/builder-pattern","result":{"data":{"markdownRemark":{"html":"<p>Builder pattern might be used in regular code, but I personally find it the most useful in tests. This is where you need to create objects which on one hand need to meet certain circumstances and on the other hand  you do not want to be bothered with other parameters. The builder pattern is the answer.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/917a330201d6ad85910d1d66c2640c46/c08c5/builder.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.89189189189189%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAwABAv/EABQBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAXAOytjg/wD/xAAaEAACAwEBAAAAAAAAAAAAAAACAwABEQQi/9oACAEBAAEFAq6IZ+tg3F3rmK0v/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERUf/aAAgBAwEBPwFDuH//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8BqY//xAAbEAACAQUAAAAAAAAAAAAAAAAAERASMTJBUf/aAAgBAQAGPwLEVGosPo2f/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERMSFB/9oACAEBAAE/IaRZ9Obo1w0SIVeoUpSySm2vEf/aAAwDAQACAAMAAAAQEx//xAAZEQACAwEAAAAAAAAAAAAAAAAAAREhMeH/2gAIAQMBAT8QeMZbwf/EABkRAAMAAwAAAAAAAAAAAAAAAAABESExsf/aAAgBAgEBPxC3cDTvp//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExQXFhkf/aAAgBAQABPxB0qXZ42cnVTtO6+5FgURS0HiK1lUHitj4AXDrz8mcCOUhP/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Image\"\n        title=\"Image\"\n        src=\"/static/917a330201d6ad85910d1d66c2640c46/1c72d/builder.jpg\"\n        srcset=\"/static/917a330201d6ad85910d1d66c2640c46/a80bd/builder.jpg 148w,\n/static/917a330201d6ad85910d1d66c2640c46/1c91a/builder.jpg 295w,\n/static/917a330201d6ad85910d1d66c2640c46/1c72d/builder.jpg 590w,\n/static/917a330201d6ad85910d1d66c2640c46/c08c5/builder.jpg 640w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<p>Let’s jump straight to a code example. We have a basic class representing a person that can have a number of friends.</p>\n<pre><code class=\"language-kotlin\">class Person (var name: String,\n    var surname: String,\n    var age: Int,\n    var gender: Gender,\n    var friends: Array&#x3C;Person>)\n</code></pre>\n<p>There is also an enum:</p>\n<pre><code class=\"language-kotlin\">enum Gender {\n    Male,\n    Female\n}\n</code></pre>\n<p>Now we will create the builder class. First of all we need a private field for every field of our Person class together with a meaningful and valid default value.</p>\n<pre><code class=\"language-kotlin\">class PersonBuilder {\n    private var name: String = \"John\",\n    private var surname: String = \"Doe\",\n    private var age: Int = 21\n    private var gender: Gender = Gender.Mail,\n    private var friends: MutableArray&#x3C;Person> = mutableArrayOf()\n}\n</code></pre>\n<p>Now we need a method for each parameter to make possible to overwrite it. Each method is returning <code>this</code> so that we can chain the methods and therefore achieve the fluent interface. </p>\n<pre><code class=\"language-kotlin\">fun withName(name: String) {\n    this.name = name\n    return this\n}\n</code></pre>\n<p>To get the actual object we need to have one more method - the <code>build</code> method.</p>\n<pre><code class=\"language-kotlin\">fun build() : Person = Person(name, surname, age, gender, friends.toTypedArray())\n</code></pre>\n<p>We can use our builder class in a test method.</p>\n<pre><code class=\"language-kotlin\">val person = PersonBuilder()\n    .withName(\"Jane\")\n    .withGender(Gender.Female)\n    .build()\n</code></pre>\n<p>In the test methods I often need just one element in the array, so I find it useful to create another method which allows for adding a single person to the array:</p>\n<pre><code class=\"language-kotlin\">fun withFriend(friend: Person) : PersonBuilder {\n    this.friends.add(friend)\n    return this\n}\n</code></pre>\n<p>Another great thing you can use along with the builder pattern are domain specific methods. Say you need an under-aged person for your tests. You could just pass the age of say 15 into the <code>withAge</code> method:</p>\n<pre><code class=\"language-kotlin\">val underAgedPerson = PersonBuilder().whitAge(15).build()\n</code></pre>\n<p>Does it clearly show the purpose? Not really. This is a kind of a magic number. Let’s add two more methods to our builder class:</p>\n<pre><code class=\"language-kotlin\">fun withAgeOfMaturity() {\n    this.age = 19\n    return this\n}\nfun withAgeOfUnderAged() {\n    this.age = 15\n    return this\n}\n</code></pre>\n<p>And now we can use it as so:</p>\n<pre><code class=\"language-kotlin\">val underAgedPerson = PersonBuilder().withAgeOfUnderAged().build()\n</code></pre>\n<p>Another typical case is when you need a set of parameter values mixed together to create a meaningful object. Say you want to create a woman person - not only do you want to set the gender but also add some feminine name.</p>\n<pre><code class=\"language-kotlin\">val woman = PersonBuilder().withGender(Gender.Female).withName(\"Jane\").build()\n</code></pre>\n<p>You can add a <code>build</code> method for this purpose:</p>\n<pre><code class=\"language-kotlin\">fun buildWoman() : Person = Person(\"Jane\", surname, age, Gender.Female, friends.toTypedArray())\n</code></pre>\n<p>Creating another <code>build</code> method for every case you can think of is a waste of time and energy. There are two main conditions to be met to decide that you need a specific <code>build</code> method:</p>\n<ul>\n<li>a set of values tend to repeat in your tests,</li>\n<li>the set of values together create a specific domain object.</li>\n</ul>\n<p>You will know the second condition is met if you can name the <code>build</code> method with the domain specific language :)</p>\n<p><strong>Kotlin Named And Default Arguments</strong></p>\n<p>There is another approach I’ve come along recently which made me realize I was using Java approach poorly adapted in Kotlin. You can make a great use of Kotlin default arguments as well as named arguments in the constructor. You can read the whole story <a href=\"https://praveer09.github.io/technology/2015/12/26/writing-test-data-builders-made-easy-with-kotlin\">here</a> or move on to an example.</p>\n<p>Instead of writing each <code>with</code> method you just declare the private fields as optional constructor parameters. The <code>build</code> method stays the same as before.</p>\n<pre><code class=\"language-kotlin\">class PersonBuilder (\n    var name: String = “John”,\n    var surname: String = “Doe”,\n    var age: Int = 21\n    var gender: Gender = Gender.Mail,\n    var friends: MutableArray&#x3C;Person> = mutableArrayOf()) {\n    \n    fun build() : Person = Person(name, surname, age, gender, friends.toTypedArray())\n}\n</code></pre>\n<p>In the forementioned blog post, the author uses immutable properties. However, if we use mutable ones, we can still make use of the additional domain specific methods. This is how the builder class looks now:</p>\n<pre><code class=\"language-kotlin\">class PersonBuilder (var name: String = \"John\",\n    var surname: String = \"Doe\",\n    var age: Int = 21\n    var gender: Gender = Gender.Mail,\n    var friends: MutableArray&#x3C;Person> = mutableArrayOf()) {\n    \n    fun build() : Person = Person(name, surname, age, gender, friends.toTypedArray())\n    \n    fun buildWoman() : Person = Person(\"Jane\", surname, age, Gender.Female, friends.toTypedArray())\n    \n    fun withFriend(friend: Person) : PersonBuilder {\n        this.friends.add(friend)\n        return this\n    }\n\n    fun withAgeOfMaturity() : PersonBuilder {\n        this.age = 19\n        return this\n    }\n    \n    fun withAgeUnderAged() : PersonBuilder {\n        this.age = 15\n        return this\n    }\n}\n</code></pre>\n<p>And this is how we can use it in tests:</p>\n<pre><code class=\"language-kotlin\">val underAgedPerson = PersonBuilder(name = \"Mickey\").withAgeUnderAged().build()\nval woman = PersonBuilder(surname = \"Smith\").buildWoman()\n</code></pre>\n<p><strong>Summary</strong></p>\n<p>Although I am an enthusiast of TDD and clearly see all the advantages of this approach, sometimes it feels really tempting to ignore the tests and go straight to coding. The more convenient tests are, the more willing you are to write them. The builder pattern is an example of what makes the tests easier to write. And easier to read, which after all might be even more important :)</p>","excerpt":"Builder pattern might be used in regular code, but I personally find it the most useful in tests. This is where you need to create objects…","frontmatter":{"slug":null,"title":"Builder pattern in Kotlin","description":null,"author":"agnieszka","tags":["kotlin","builder","pattern"],"date":"2018-01-16T23:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#d8d8e8","images":{"fallback":{"src":"/static/917a330201d6ad85910d1d66c2640c46/a962d/builder.jpg","srcSet":"/static/917a330201d6ad85910d1d66c2640c46/da65b/builder.jpg 160w,\n/static/917a330201d6ad85910d1d66c2640c46/f6fcd/builder.jpg 320w,\n/static/917a330201d6ad85910d1d66c2640c46/a962d/builder.jpg 640w","sizes":"(min-width: 640px) 640px, 100vw"},"sources":[{"srcSet":"/static/917a330201d6ad85910d1d66c2640c46/405d4/builder.webp 160w,\n/static/917a330201d6ad85910d1d66c2640c46/dde70/builder.webp 320w,\n/static/917a330201d6ad85910d1d66c2640c46/18e38/builder.webp 640w","type":"image/webp","sizes":"(min-width: 640px) 640px, 100vw"}]},"width":640,"height":426}}}},"timeToRead":4,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-17-builder-pattern.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-17-builder-pattern.md"}},"staticQueryHashes":["2189233960","3181594896"]}