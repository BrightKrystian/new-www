{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/request-typing","result":{"data":{"markdownRemark":{"html":"<h3>Introduction</h3>\n<p>As developers we often perform POST and PATCH requests to API from our frontend apps. When we use TypeScript, this code should be typed safely. There are multiple ways to do so. Let's analyze one of them!</p>\n<h3>Prerequisite</h3>\n<p>Let's imagine a player entity from a game:</p>\n<pre><code class=\"language-typescript\">// Create a type for our object\ntype PlayerType = {\n  hp: number\n  name: string\n  position: [number, number]\n}\n\n// We can also use interface:\ninterface PlayerInterface {\n  hp: number\n  name: string\n  position: [number, number]\n}\n</code></pre>\n<p>Let's create two functions (without safe type control as for now) to create and update our player:</p>\n<pre><code class=\"language-typescript\">const postPlayer = (data: any) => {\n  // API call with POST method, here as data whole Player object should be sent. \n}\n\nconst patchPlayer = (data: any) => {\n  // API call with PATCH method, here as data Player object can be sent as a whole or partialy. \n}\n</code></pre>\n<h3>Safe typing</h3>\n<p>Leaving type <code>any</code> can lead application to behave erroneous moreover we do not benefit from TypeScript static type\nchecking. <strong>Avoid</strong> leaving <code>any</code> in code - there is probably a better solution!</p>\n<p>Statically typed functions arguments could look like this:</p>\n<pre><code class=\"language-typescript\">// Here we use PlayerType (or PlayerInterface) type as API require whole object \nconst postPlayer = (data: PlayerType | PlayerInterface) => { }\n\n// Example of \"keyof\" operator\ntype PlayerTypeKeys = keyof PlayerType // \"hp\" | \"name\" | \"position\"\n\n// Copy of PlayerType type with \"?\" beeing added - this will change object properties to be optional\ntype PlayerTypeOptional = {\n  [K in keyof PlayerType]?: PlayerType[K]\n}\n\n// Here we use PlayerOptional (or partial of PlayerInterface) type as API does not require whole object\nconst patchPlayer = (data: PlayerTypeOptional | Partial&#x3C;PlayerInterface>) => { }\n</code></pre>\n<p>Let's test our type for safety:</p>\n<pre><code class=\"language-typescript\">// Here we create objects which later will be send to API thre proper functions\nconst player1: PlayerType = { hp: 10, name: \"Albert\", position: [10, 1] }\nconst player2: PlayerInterface = { hp: 20, name: \"Antony\", position: [2, 20] }\nconst player3: PlayerTypeOptional = { name: \"Alex\" }\nconst player4: Partial&#x3C;PlayerInterface> = { hp: 2 }\n\n// Results\npostPlayer(player1)     // OK\npostPlayer(player2)     // OK\npostPlayer(player3)     // Error\npostPlayer(player4)     // Error\npatchPlayer(player1)    // OK \npatchPlayer(player2)    // OK \npatchPlayer(player3)    // OK \npatchPlayer(player4)    // OK\n</code></pre>\n<h3>Additional info</h3>\n<p>Similarly to adding optional (\"?\") modificator on <code>PlayerType</code> we can add by \"+\" (this sign can be omitted) or\nremove by \"-\" (this sign is required) readonly modificator:</p>\n<pre><code class=\"language-typescript\">type PlayerTypeReadonlyOne = {\n  readonly [K in keyof PlayerType]: PlayerType[K]\n}\n\ntype PlayerTypeReadonlyTwo = {\n  +readonly [K in keyof PlayerTypeOptional]-?: PlayerTypeOptional[K]\n}\n\ntype PlayerTypeOptionalTwo = {\n  -readonly [K in keyof PlayerTypeReadonlyOne]+?: PlayerTypeReadonlyOne[K]\n}\n\n// types PlayerTypeReadonlyOne and PlayerTypeReadonlyTwo are equivalent\nconst player5: PlayerTypeReadonlyOne = { hp: 1, name: \"One\", position: [1, 1] }\nconst player6: PlayerTypeReadonlyTwo = { hp: 2, name: \"Two\", position: [2, 2] }\n\n// types PlayerTypeOptional and PlayerTypeOptionalTwo are equivalent\nconst player7: PlayerTypeOptionalTwo = { position: [2, 2] }\n</code></pre>\n<p>As an alternative while using interface <code>SomeInterface</code> instead of type we can use a combination of\n<code>Readonly&#x3C;SomeInterface></code>, <code>Required&#x3C;SomeInterface></code>.</p>\n<h3>Conclusion</h3>\n<p>Proper API typing increase benefits from TypeScript static type checking and makes our development safer. Knowledge on\nhow to work with types or interfaces can help us find a way to do so in a DRY way!</p>","excerpt":"Introduction As developers we often perform POST and PATCH requests to API from our frontend apps. When we use TypeScript, this code shouldâ€¦","frontmatter":{"slug":null,"title":"Object typing","description":null,"author":"wojciech","tags":["typescript","types","API","frontend"],"date":"2021-01-06T12:12:12.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/8a3785aa48d04bbcbb34a354376a4b7e/c7636/request_typing.png","srcSet":"/static/8a3785aa48d04bbcbb34a354376a4b7e/1aa8f/request_typing.png 175w,\n/static/8a3785aa48d04bbcbb34a354376a4b7e/65f9b/request_typing.png 350w,\n/static/8a3785aa48d04bbcbb34a354376a4b7e/c7636/request_typing.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/8a3785aa48d04bbcbb34a354376a4b7e/8b01d/request_typing.webp 175w,\n/static/8a3785aa48d04bbcbb34a354376a4b7e/e8f67/request_typing.webp 350w,\n/static/8a3785aa48d04bbcbb34a354376a4b7e/912fb/request_typing.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":277}}}},"timeToRead":2,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2021-01-06-request-typing.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2021-01-06-request-typing.md"}},"staticQueryHashes":["2189233960","3181594896"]}