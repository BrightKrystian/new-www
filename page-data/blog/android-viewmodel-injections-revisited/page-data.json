{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/android-viewmodel-injections-revisited","result":{"data":{"markdownRemark":{"html":"<p>In one of <a href=\"https://brightinventions.pl/blog/injectable-android-viewmodels/\">my previous posts</a> I have described how to implement a ViewModel factory that was able to provide ViewModels with their dependencies injected, e.g. an API client, and it was good enough for me at that time. Later on, thanks to <a href=\"https://miensol.pl/\">Piotr</a>, we've found out even better and simpler approach with an additional possibility of injecting Activity- or Fragment-dependant data into ViewModels.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4d015581f2d4faf1645a7b8e89e5b55c/eea4a/vaccine.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.89189189189189%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHfnRYYCv/EABgQAAMBAQAAAAAAAAAAAAAAAAECEAAS/9oACAEBAAEFAsrdCBQJ/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxABAAMAAAAAAAAAAAAAAAAAARAgIf/aAAgBAQAGPwKmBH//xAAZEAEAAgMAAAAAAAAAAAAAAAABEBEAIXH/2gAIAQEAAT8hw7NSHQuEf//aAAwDAQACAAMAAAAQ68//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEBAAIDAAAAAAAAAAAAAAABEQAQITFR/9oACAEBAAE/EMsaGpB80gkeTJ5NWAd6/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Vaccine\"\n        title=\"Vaccine\"\n        src=\"/static/4d015581f2d4faf1645a7b8e89e5b55c/1c72d/vaccine.jpg\"\n        srcset=\"/static/4d015581f2d4faf1645a7b8e89e5b55c/a80bd/vaccine.jpg 148w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/1c91a/vaccine.jpg 295w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/1c72d/vaccine.jpg 590w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/a8a14/vaccine.jpg 885w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/fbd2c/vaccine.jpg 1180w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/eea4a/vaccine.jpg 1280w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>{: .center-image}</p>\n<h1>Simpler factory</h1>\n<p>Previously, we've created a singleton factory that was supplied with a map of <code>ViewModel</code>-based classes and their respective <code>Provider</code>s. It required us to create a custom <code>ViewModelKey</code> annotation and use Dagger to generate the map using <code>IntoMap</code> bindings. It didn't require a lot of boilerplate code compared to some other solutions I saw at that time, but it wasn't perfect either.</p>\n<p>On the contrary, the new solution is based on a generic ViewModel factory class of which instances are created for each Activity or Fragment instance.</p>\n<pre><code class=\"language-kotlin\">import android.arch.lifecycle.ViewModel\nimport android.arch.lifecycle.ViewModelProvider\nimport dagger.Lazy\nimport javax.inject.Inject\n\nclass ViewModelFactory&#x3C;VM : ViewModel> @Inject constructor(\n    private val viewModel: Lazy&#x3C;VM>\n) : ViewModelProvider.Factory {\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun &#x3C;T : ViewModel> create(modelClass: Class&#x3C;T>): T {\n        return viewModel.get() as T\n    }\n}\n</code></pre>\n<p>For example (see the <a href=\"https://github.com/azabost/simple-mvvm-example\">full code here</a>):</p>\n<pre><code class=\"language-kotlin\">class MainViewModel @Inject constructor(\n    private val apiClient: ApiClient\n) : ViewModel() {\n    // ...\n}\n\nclass MainActivity : BaseActivity() {\n\n    @Inject\n    lateinit var vmFactory: ViewModelFactory&#x3C;MainViewModel>\n\n    lateinit var vm: MainViewModel\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        vm = ViewModelProviders.of(this, vmFactory)[MainViewModel::class.java]\n\n        // ...\n    }\n}\n</code></pre>\n<p>As you can see, there is much less code and personally I think it's also easier to understand. To make it even more concise, we can add an extension function in the <code>BaseActivity</code> class like this:</p>\n<pre><code class=\"language-kotlin\">abstract class BaseActivity : AppCompatActivity() {\n    // ...\n\n    inline fun &#x3C;reified T : ViewModel> ViewModelFactory&#x3C;T>.get(): T =\n        ViewModelProviders.of(this@BaseActivity, this)[T::class.java]\n}\n</code></pre>\n<p>Then, we can get a ViewModel with just: <code>vm = vmFactory.get()</code></p>\n<p>Analogically, we can add a similar function for Fragments.</p>\n<h1>More possibilities</h1>\n<p>One of the issues we've had was that the singleton factory holding a map of ViewModel providers was widely scoped, therefore it wouldn't let us inject anything coming from a more narrow scope, e.g. Activity's extras or Fragment's arguments.</p>\n<p>Creating a new factory each time makes it possible. In order to achieve this, we need an additional module that knows how to obtain the dependencies. For example:</p>\n<pre><code class=\"language-kotlin\">import com.azabost.simplemvvm.net.response.RepoResponse\nimport dagger.Module\nimport dagger.Provides\n\n@Module\nclass RepoActivityIntentModule {\n    @Provides\n    fun providesRepoResponse(activity: RepoActivity): RepoResponse {\n        return activity.intent.getSerializableExtra(RepoActivity.REPO_RESPONSE_EXTRA) as RepoResponse\n    }\n}\n</code></pre>\n<p>This module must then be added to the respective <code>RepoActivity</code> subcomponent generated by the <code>ContributesAndroidInjector</code> annotation:</p>\n<pre><code class=\"language-kotlin\">import com.azabost.simplemvvm.ui.main.MainActivity\nimport com.azabost.simplemvvm.ui.repo.RepoActivity\nimport com.azabost.simplemvvm.ui.repo.RepoActivityIntentModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class AndroidInjectorsModule {\n    @ContributesAndroidInjector\n    abstract fun contributeMainActivity(): MainActivity\n\n    @ContributesAndroidInjector(modules = [RepoActivityIntentModule::class])\n    abstract fun contributeRepoActivity(): RepoActivity\n}\n</code></pre>\n<p>Finally, when we get our <code>RepoViewModel</code> in the <code>RepoActivity</code>, it has the data coming from the intent already injected:</p>\n<pre><code class=\"language-kotlin\">class RepoViewModel @Inject constructor(\n    val repoResponse: RepoResponse\n) : ViewModel()\n\nclass RepoActivity : BaseActivity() {\n\n    @Inject\n    lateinit var vmFactory: ViewModelFactory&#x3C;RepoViewModel>\n\n    lateinit var vm: RepoViewModel\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_repo)\n\n        vm = ViewModelProviders.of(this, vmFactory)[RepoViewModel::class.java]\n\n        repoData.text = vm.repoResponse.id.toString()\n    }\n\n    companion object {\n        const val REPO_RESPONSE_EXTRA = \"REPO_RESPONSE_EXTRA\"\n    }\n}\n</code></pre>","excerpt":"In one of my previous posts I have described how to implement a ViewModel factory that was able to provide ViewModels with theirâ€¦","frontmatter":{"slug":null,"title":"Android ViewModel injections revisited","description":null,"author":"azabost","tags":["android"],"date":"2018-06-18T00:00:00.000Z","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/4d015581f2d4faf1645a7b8e89e5b55c/f3dc5/vaccine.jpg","srcSet":"/static/4d015581f2d4faf1645a7b8e89e5b55c/f6fcd/vaccine.jpg 320w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/e70fc/vaccine.jpg 640w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/f3dc5/vaccine.jpg 1280w","sizes":"(min-width: 1280px) 1280px, 100vw"},"sources":[{"srcSet":"/static/4d015581f2d4faf1645a7b8e89e5b55c/dde70/vaccine.webp 320w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/62859/vaccine.webp 640w,\n/static/4d015581f2d4faf1645a7b8e89e5b55c/f121e/vaccine.webp 1280w","type":"image/webp","sizes":"(min-width: 1280px) 1280px, 100vw"}]},"width":1280,"height":853}}}},"timeToRead":3,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-06-14-android-viewmodel-injections-revisited.md"},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-06-14-android-viewmodel-injections-revisited.md"}},"staticQueryHashes":["2189233960","3181594896"]}